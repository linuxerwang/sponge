= Integration

== Spring framework
{sponge} engine may be configured as a Spring bean. That configuration provides standardized access to an embedded {sponge} engine for example in J2EE environment.

To provide access to the Spring `ApplicationContext` in the knowledge base, the `SpringPlugin` instance should be created, *configured as a Spring bean and added to the {sponge} engine*. The Spring plugin shouldn't be defined in {sponge} XML configuration file.

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/spring/SpringPlugin.html[`SpringPlugin` Javadoc].

.Spring Java configuration example
[source,java]
----
@Configuration
public class TestConfig {

    @Bean
    public Engine spongeEngine() { // <1>
        return SpringSpongeEngine.builder().plugin(springPlugin()).knowledgeBase("kb", "examples/spring/spring.py").build(); // <2>
    }

    @Bean
    public SpringPlugin springPlugin() { // <3>
        return new SpringPlugin();
    }

    @Bean
    public String testBean() {
        return BEAN_VALUE;
    }
}
----
<1> The engine configured as the Spring bean. The `SpringSpongeEngine` implementation is used here in order to startup and shutdown the engine by Spring. `DefaultSpongeEngine` could also be used here but it wouldn't provide automatic startup and shutdown.
<2> Added `SpringPlugin`.
<3> `SpringPlugin` configured as the Spring bean.

.Python knowledge base
[source,python]
----
class SpringTrigger(Trigger):
    def onConfigure(self):
        self.event = "springEvent"
    def onRun(self, event):
        beanValue = spring.context.getBean("testBean") # <1>
        self.logger.debug("Bean value = {}", beanValue)
----
<1> A Spring bean named `"testBean"` is acquired from the Spring `ApplicationContext` by using `SpringPlugin` instance referenced by the `spring` variable.

The `SpringSpongeEngine` starts up automatically (in the `afterPropertiesSet` Spring callback method) by default. However it may be configured not to start automatically by setting `autoStartup` to `false`.

.SpringSpongeEngine not starting automatically example
[source,java]
----
@Bean
public SpongeEngine spongeEngine() {
    return SpringSpongeEngine.builder().autoStartup(false).plugin(springPlugin()).knowledgeBase("kb", "examples/spring/spring.py").build();
}
----

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml` for this component:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-spring</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== Apache Camel

=== {sponge} Camel component
The *sponge* component provides integration bridge between Apache Camel and the {sponge} engine. It allows:

* to route a body of a Camel message to the {sponge} engine by converting it to a {sponge} event (producer endpoint),
* to route a message from a {sponge} knowledge base to a Camel route (consumer endpoint).

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml` for this component:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-camel</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== URI format
[source,java]
----
sponge:engineRef[?options]
----
Where `engineRef` represents the name of the `SpongeEngine` implementation instance located in the Camel registry.

=== Options

[cols="1,2,5"]
|===
|Name |Default value |Description

|`action`
|`"CamelProducerAction"`
|Could be used only on the producer side of the route. It will synchronously call the {sponge} action that has a name specified by the value of this option. However if there is the header named *CamelSpongeAction* in the Camel In message, it would override the value of this option.

|`managed`
|`true`
|If set to `true` the {sponge} engine will be started automatically when the endpoint starts and will be shut down when the endpoint stops.
|===

=== {sponge} support for Camel

==== CamelPlugin
`CamelPlugin` provides an interface to the Camel context so it may be used in a knowledge base. 

`CamelPlugin` may be configured in three different ways.

* Explicitly as a Spring bean and assigned to the engine using the Engine Builder API. This is the preferred way.
+
.Example
[source,python]
----
@Configuration
public class SpringConfiguration extends SpongeCamelConfiguration {

    @Bean
    public SpongeEngine spongeEngine() {
        return SpringSpongeEngine.builder()
                .config("config.xml")
                .plugin(camelPlugin())
                .build();
    }
}
----
* Implicitly when creating a {sponge} Camel endpoint.
* Explicitly in the {sponge} XML configuration file.
+
.Example
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="http://sponge.openksavi.org" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://sponge.openksavi.org http://sponge.openksavi.org/schema/config.xsd">

    <plugins>
        <!-- Note: don't change the plugin name. -->
        <plugin name="camel" class="org.openksavi.sponge.camel.CamelPlugin" />
    </plugins>
</sponge>
----

TIP: If you use an implicit configuration and you get an error stating that `camel` variable is not defined, it signifies that a Camel context is not configured yet or {sponge} engine is not used in any Camel route.

Only one `CamelContext` may be used with one instance of {sponge} engine, bound by a single `CamelPlugin`.

.Important CamelPlugin properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`send(body)`
|Sends the body to all current consumers.

|`send(uri, body)`
|Sends the body to an endpoint.

|`request(uri, body)`
|Sends the body to an endpoint returning any result output body.

|`getContext()`
|Returns a Camel context.

|`getConsumers()`
|Returns the current list of consumers.
|===

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/camel/CamelPlugin.html[`CamelPlugin` Javadoc].


==== Spring-based support
`SpongeCamelConfiguration` provides base Camel and {sponge} configuration using Spring Java configuration. Your Spring configuration could inherit from this class.

Spring bean named `"spongeProducerTemplate"` allows you to configure a Camel producer template used by `CamelPlugin` to send Camel messages. If none is present in a Spring configuration, then a default will be used.

Spring bean named `springPlugin` is the instance of `SpringPlugin` that could be registered in the engine and used in knowledge bases as the `spring` variable.

Spring bean named `camelPlugin` is the instance of `CamelPlugin` that could be registered in the engine and used in knowledge bases as the `camel` variable.

=== Producer
Using sponge component on the producer side of the route will forward a body of a Camel message to the specified {sponge} engine.

{sponge} in a producer mode could be placed in many routes in one Camel context.

.Producer example - Spring configuration
[source,java]
----
@Configuration
public class ExampleConfiguration extends SpongeCamelConfiguration {

    @Bean
    public SpongeEngine spongeEngine() {
        // Use EngineBuilder API to create an engine. Also bind Spring and Camel plugins as beans manually.
        return SpringSpongeEngine.builder()
                .knowledgeBase("camelkb", "examples/camel/camel_producer.py")
                .plugins(springPlugin(), camelPlugin())
                .build();
    }

    @Bean
    public RouteBuilder exampleRoute() {
        return new RouteBuilder() {
            @Override
            public void configure() {
                from("direct:start").routeId("spongeProducer")
                    .to("sponge:spongeEngine");
            }
        };
    }
}
----

.Python knowledge base `camel_producer.py`
[source,python]
----
class CamelTrigger(Trigger):
    def onConfigure(self):
        self.event = "spongeProducer"
    def onRun(self, event):
        print event.body
----

.Producer example - Sample code that sends a Camel message
[source,java]
----
// Starting a Spring context.
GenericApplicationContext context = new AnnotationConfigApplicationContext(ExampleConfiguration.class);
context.start();

// Sending a Camel message.
CamelContext camel = context.getBean(CamelContext.class);
ProducerTemplate producerTemplate = camel.createProducerTemplate();
producerTemplate.sendBody("direct:start", "Send me to the Sponge");

// Waiting for the engine to process an event.
----

.Output console
[source,bash,subs="verbatim,attributes"]
----
Send me to the Sponge
----

==== Camel producer action
Camel producer action will be invoked by {sponge} synchronously when a Camel exchange comes to the {sponge} engine. The result returned by this action is placed as the body of the Camel _IN_ message. So it may be used by the next endpoint in the route if there is any.

NOTE: To avoid misconception please note that events in the Output Event Queue are not sent to the Camel route.

===== Default Camel producer action
The default Camel producer action is provided by a Java action `CamelProducerAction`. If the body of the Camel message is a {sponge} event or event definition, than the event is sent to the {sponge} immediately. Otherwise this action creates and sends a new event that encapsulates the body. The event is then returned, so it is placed as the body of the Camel In message. The default name of the new event is the name of the corresponding Camel route.

===== Custom Camel producer action
You could provide a custom implementation of a Camel producer action in two ways:

* define your own implementation of `CamelProducerAction` in a knowledge base,
* define an action in a knowledge base that takes an instance of `Exchange` as an argument and specify it in the producer endpoint URI or in the message header, e.g.:
+
.Python knowledge base
[source,python]
----
class CustomAction(Action):
    def onCall(self, exchange):
        return "OK"
----
+
.Camel route that sets the action in the endpoint URI
[source,java]
----
from("direct:start").routeId("spongeProducer")
        .to("sponge:spongeEngine?action=CustomAction")
        .log("Action result as a body: ${body}");
----
+
.Camel route that sets the action in the header
[source,java]
----
from("direct:start").routeId("spongeProducer")
        .setHeader("CamelSpongeAction", constant("CustomAction"))
        .to("sponge:spongeEngine)
        .log("Action result as a body: ${body}");
----

=== Consumer
Using sponge component on the consumer side of the route will forward messages sent from the specified {sponge} engine to a Camel route.

{sponge} in a consumer mode could be placed in many routes in one Camel context.

.Consumer example - Spring configuration
[source,java]
----
@Configuration
public class ExampleConfiguration extends SpongeCamelConfiguration {

    @Bean
    public SpongeEngine spongeEngine() {
        // Use EngineBuilder API to create an engine. Also bind Spring and Camel plugins as beans manually.
        return SpringSpongeEngine.builder()
                .knowledgeBase("camelkb", "examples/camel/camel_consumer.py")
                .plugins(springPlugin(), camelPlugin())
                .build();
    }

    @Bean
    public RouteBuilder exampleRoute() {
        return new RouteBuilder() {

            @Override
            public void configure() {
                from("sponge:spongeEngine").routeId("spongeConsumer")
                    .log("${body}")
                    .to("stream:out");
            }
        };
    }
}
----

.Python knowledge base `camel_simple_consumer.py`
[source,python]
----
class CamelTrigger(Trigger):
    def onConfigure(self):
        self.event = "spongeEvent"
    def onRun(self, event):
        camel.send(event.get("message"))

    EPS.event("spongeEvent").set("message", "Send me to Camel")
----

The variable `camel` is a reference to the instance of `CamelPlugin` that is associated with the Camel context.

.Output console
[source,bash,subs="verbatim,attributes"]
----
Send me to Camel
----

You may also send a message to the Camel endpoint directly, e.g.:
[source,python]
----
camel.send("direct:log", event.get("message"))
----
This allows you, for example, to create a flexible message flow using Camel routes and {sponge} as a dispatcher.

=== Routes in scripting languages
`ScriptRouteBuilder` class introduces `fromS` methods (meaning _from Script_) that delegate to the corresponding `from` methods in order to avoid using `from` since it could be a reserved keyword in scripting languages (e.g. in Python). So when defining Camel routes in Python you should use this class instead of standard `RouteBuilder`, e.g.:

[source,python]
----
from org.openksavi.sponge.camel import ScriptRouteBuilder

class PythonRoute(ScriptRouteBuilder):
    def configure(self):
        self.fromS("sponge:spongeEngine").routeId("spongeConsumerCamelPython") \
                .transform().simple("${body}") \
                .process(lambda exchange: EPS.getVariable("receivedRssCount").incrementAndGet()) \
                .to("stream:out")

def onStartup():
    camel.context.addRoutes(PythonRoute())
----

== Python (CPython)
{sponge} may communicate with external programs written in the reference implementation of the Python programming language - https://en.wikipedia.org/wiki/CPython[CPython] using https://www.py4j.org[Py4J], and vice versa. A Python program and a {sponge} Java process communicate through network sockets.

Py4J by default uses the TCP port 25333 to communicate from Python to Java and TCP port 25334 to communicate from Java to Python.

There is no support for writing knowledge bases in CPython.

The CPython environment must have Py4J installed, e.g.:

[source,bash]
----
pip install py4j
----

For more information on Py4J see https://www.py4j.org/advanced_topics.html.

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-py4j</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== Py4J plugins

{sponge} provides two plugins for integration with CPython.

WARNING: Local network sockets used by Py4j should be secured, for example using [https://www.py4j.org/advanced_topics.html#tls]TLS. Please be aware that all {sponge} operations are accessible in other processes that communicate with the {sponge} with Py4J enabled by a plugin. See {py4jSourcesUrl}/java_server_tls for an example of TLS security, based on Py4J examples. Note that in a production environment you should customize this simple configuration, possibly by providing your own configured instance of `GatewayServer` or `ClientServer` to the plugin.

.Py4J plugin common configuration parameters
[cols="1,1,4"]
|===
|Name |Type |Description

|`facadeInterface`
|`String`
|A Java interface that is a facade to the Py4J entry point object configured on the CPython side.

|`javaPort`
|`Integer`
|Java side server port.

|`pythonPort`
|`Integer`
|CPython side server port.

|`security/keyStore`
|`String`
|Simple security keystore file location on the classpath.

|`security/keyStorePassword`
|`String`
|Simple security keystore password.

|`security/keyPassword`
|`String`
|Simple security key password.

|`security/algorithm`
|`String`
|Simple security algorithm. The default value is `SunX509`.
|===

==== GatewayServerPy4JPlugin

`GatewayServerPy4JPlugin` provides integration with CPython using Py4J `GatewayServer`.

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/py4j/GatewayServerPy4JPlugin.html[`GatewayServerPy4JPlugin` Javadoc].

[discrete]
===== {sponge} side example

.GatewayServerPy4JPlugin XML configuration example
[source,xml,subs="verbatim,attributes"]
----
<sponge>
    <plugins>
        <plugin name="py4j" class="org.openksavi.sponge.py4j.GatewayServerPy4JPlugin" />
    </plugins>
</sponge>
----

[discrete]
===== CPython side example

.Sending {sponge} event in CPython
[source,python]
----
from py4j.java_gateway import JavaGateway

gateway = JavaGateway()

# EPS in other process accessed via Py4J
EPS = gateway.entry_point

print "Connected to {}".format(EPS.getInfo())
EPS.event("helloEvent").set("say", "Hello from Python's Py4J").send()
----

Note that a simplified bean property access is not supported here. So instead of `EPS.info` you have to invoke `EPS.getInfo()`.

==== ClientServerPy4JPlugin

`ClientServerPy4JPlugin` provides integration with CPython using Py4J `ClientServer`.

.ClientServerPy4JPlugin plugin specific configuration parameters
[cols="1,1,4"]
|===
|Name |Type |Description

|`autoStartJavaServer`
|`Boolean`
|Auto start of Py4J JavaServer.
|===

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/py4j/ClientServerPy4JPlugin.html[`ClientServerPy4JPlugin` Javadoc].

[discrete]
===== {sponge} side example

.ClientServerPy4JPlugin XML configuration example
[source,xml,subs="verbatim,attributes"]
----
<sponge>
    <plugins>
        <plugin name="py4j" class="org.openksavi.sponge.py4j.ClientServerPy4JPlugin">
            <configuration>
                <facadeInterface>org.openksavi.sponge.py4j.PythonService</facadeInterface>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

.Python facade interface
[source,java]
----
public interface PythonService {
    String toUpperCase(String text);
}
----

.ClientServerPy4JPlugin knowledge base example written in Jython
[source,python]
----
# Note that this code is interpreted by Jython in Sponge, not CPython
class PythonUpperCase(Action):
    def onCall(self, text):
        result = py4j.facade.toUpperCase(text)
        self.logger.debug("CPython result for {} is {}", text, result)
        return result
----

[discrete]
===== CPython side example

.Implementation of the facade interface in CPython
[source,python]
----
from py4j.clientserver import ClientServer

class PythonService(object):
    def toUpperCase(self, text):
        return text.upper()
    class Java:
        implements = ["org.openksavi.sponge.py4j.PythonService"]

pythonService = PythonService()
gateway = ClientServer(python_server_entry_point=pythonService)
----

== MIDI
The MIDI plugin (`MidiPlugin`) allows processing https://en.wikipedia.org/wiki/MIDI[MIDI] messages by the {sponge} and provides communication with MIDI devices. It wraps MIDI messages in {sponge} events. The plugin supports `ShortMessage`, `MetaMessage` and `SysexMessage` MIDI messages wrapping them respectively in `MidiShortMessageEvent`, `MidiMetaMessageEvent` and `MidiSysexMessageEvent` {sponge} events. Although the MIDI support in the {sponge} provides a set of methods that use the `javax.sound.midi` API, the goal of this plugin is not to be a complete interface to the MIDI system but a bridge between MIDI messages and {sponge} events.

The default name of the MIDI plugin (which may be used in knowledge bases) is `midi`.

.MIDI plugin configuration parameters
[cols="1,1,4"]
|===
|Name |Type |Description

|`sequencerConnectedToSynthesizer`
|`Boolean`
|If `true` then the default MIDI sequencer will be connected to the default synthesizer (e.g. to generate sound while playing MIDI files). The default value is `false`.

|`loadAllInstruments`
|`Boolean`
|If `true` then all instruments in the default soundbank will be loaded at startup. The default value is `true`.

|`midiShortMessageEventName`
|`String`
|A name of a MIDI ShortMessage {sponge} event sent by this plugin to the engine. The default value is `"midiShort"`.

|`midiMetaMessageEventName`
|`String`
|A name of a MIDI MetaMessage {sponge} event sent by this plugin to the engine. The default value is `"midiMeta"`.

|`midiSysexMessageEventName`
|`String`
|A name of a MIDI SysexMessage {sponge} event sent by this plugin to the engine. The default value is `"midiSysex"`.
|===

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/midi/MidiPlugin.html[`MidiPlugin` Javadoc].

.Example Python knowledge base that shows how to process MIDI messages created by an external MIDI input device
[source,python]
----
from javax.sound.midi import ShortMessage
from org.openksavi.sponge.midi import MidiUtils

class SameSound(Trigger):
    def onConfigure(self):
        self.event = "midiShort" # <1>
    def onRun(self, event):
        midi.sound(event.message) # <2>

class Log(Trigger):
    def onConfigure(self):
        self.event = "midiShort"
    def onRun(self, event):
        self.logger.info("{}Input message: {}", "[" + MidiUtils.getKeyNote(event.data1) + "] " if event.command == ShortMessage.NOTE_ON else "",
                         event.messageString) # <3>

def onStartup():
    EPS.logger.info("This example program enables a user to play an input MIDI device (e.g. a MIDI keyboard) using the Sponge MIDI plugin.")
    midi.connectDefaultInputDevice() # <4>
    EPS.logger.info("Input MIDI device: {}", midi.inputDevice.deviceInfo.name)
    EPS.logger.info("Instruments: {}", ",".join(list(map(lambda i: i.name + " (" + str(i.patch.bank) + "/" + str(i.patch.program) + ")", midi.instruments))))
    midi.setInstrument(0, "Electric Piano 1") # <5>
----
<1> The trigger `SameSound` listens to all MIDI short messages.
<2> The trigger `SameSound` sends all MIDI short messages received from the input MIDI device to the MIDI synthesizer to generate sounds. It is achieved through the use of the `sound` method in the `midi` plugin.
<3> The trigger `Log` only logs a MIDI message info and a note for _note on_ MIDI messages.
<4> Connects a default input MIDI device in the system (e.g. a MIDI keyboard) to the MIDI plugin in order to receive all MIDI messages generated by this device and send them to the {sponge} engine as {sponge} events.
<5> Sets the instrument (by name) in the MIDI synthesizer for the MIDI channel `0`. Note that this example assumes that the input MIDI device will generate MIDI messages for the same channel.

NOTE: An event flow in the {sponge} engine introduces an additional performance overhead that in some situations may be not acceptable when dealing with real-time physical MIDI instruments.

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-midi</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== MPD
The MPD plugin (`MpdPlugin`) provides an integration with an https://en.wikipedia.org/wiki/Music_Player_Daemon[MPD (Music Player Daemon)] server. The integration allows knowledge bases to manage an MPD server and gives the possibility to process MPD based events.

NOTE: The plugin is located in the `sponge-mpd` {sponge} external module. The reason that the MPD support is located in the external {sponge} module is that *it is released under http://www.gnu.org/copyleft/gpl.html[GNU GPL Version 3] license* which is not compatible with the {sponge} Apache 2.0 license. This requirement is forced by the license of the underlying library https://github.com/finnyb/javampd[JavaMPD].

The default name of the MPD plugin (which may be used in knowledge bases) is `mpd`.

The MPD plugin provides a simple predefined knowledge base library.

.Example use of the MPD predefined knowledge base library
[source,xml]
----
<knowledgeBase name="mpd" displayName="MPD">
    <file>classpath*:org/openksavi/sponge/mpd/mpd_library.py</file>
</knowledgeBase>
----

.MPD plugin configuration parameters
[cols="1,1,4"]
|===
|Name |Type |Description

|`hostname`
|`String`
|The MPD server hostname.

|`port`
|`Integer`
|The MPD server port.

|`password`
|`String`
|The MPD server password.

|`timeout`
|`Integer`
|The MPD server timeout.

|`eventNamePrefix`
|`String`
|The MPD-based Sponge event name prefix. The default value is `"mpd"`.

|`autoConnect`
|`Boolean`
|The auto connect flag. If `true` (the default value), the plugin connects to the MPD server on startup.

|`autoStartMonitor`
|`Boolean`
|The auto start monitor flag. If `true` (the default value), the plugin starts the MPD monitor. The MPD monitor allows the plugin to send MPD based events to the engine.
|===

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/mpd/MpdPlugin.html[`MpdPlugin` Javadoc] and http://finnyb.github.io/javampd/[JavaMPD].

The following example searches for albums in the MPD database matching the given criteria and adds them to the playlist.

.Example Python knowledge base
[source,python]
----
def selectAlbums(albums, yearMin, yearMax, genreRegexp):
    selectedAlbums = []
    for album in albums:
        if album.date and album.date >= str(yearMin) and album.date <= str(yearMax) and album.genre and re.match(genreRegexp.lower(), album.genre.lower()):
            selectedAlbums.append(album)
    return selectedAlbums

def setAndPlayPlaylist(albums):
    if len(albums) == 0:
        return
    mpd.server.playlist.clearPlaylist() # <1>
    mpd.server.playlist.insertAlbum(albums[0])
    # Play immediately after inserting the first album
    mpd.server.player.play()
    for album in albums[1:]:
        mpd.server.playlist.insertAlbum(album) 

def onStartup():
    albums = mpd.server.musicDatabase.albumDatabase.listAllAlbums()
    EPS.logger.info("MPD server version: {}. All album count: {}", mpd.server.version, len(albums))

    EPS.logger.info("Setting the playlist...")
    # Set the playlist to rock albums released since 1970 
    selectedAlbums = selectAlbums(albums, 1970, 2018, ".*(Rock).*")
    if len(selectedAlbums) > 0:
        setAndPlayPlaylist(selectedAlbums)
        EPS.logger.info("The playlist is set, {} albums found", len(selectedAlbums))
    else:
        EPS.logger.info("No matching albums found")
----
<1> The `mpd.server` is a reference to the instance of the `MPD` class (part of JavaMPD library) which represents a connection to a MPD server.

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-mpd</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== Raspberry Pi - Pi4J
The Pi4J plugin (`Pi4JPlugin`) allows using the http://pi4j.com[Pi4J] library in {sponge} knowledge bases. The Pi4J library provides a friendly object-oriented I/O API and implementation libraries to access the full I/O capabilities of the Raspberry Pi platform. The current version of the plugin is very simple. For example it hasn't got any configuration parameters.

The default name of the Pi4J plugin (which may be used in knowledge bases) is `pi4j`.

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/rpi/pi4j/Pi4JPlugin.html[`Pi4JPlugin` Javadoc].

The following example shows how to turn on/off a Grove LED connected to the Raspberry Pi GPIO. The hardware setup for this example includes Raspberry Pi 3, a ribbon cable, a ribbon cable socket, a breadboard, a 4-pin male jumper to Grove 4 pin conversion cable and a Grove LED. Before setting up the hardware make sure that your Raspberry Pi is not powered! The Grove LED should be connected to GPIO via a 4-pin connector: the black wire goes on PIN#14 (Ground), the red wire goes on PIN#02 (DC Power 5V), the yellow wire goes on PIN#12 (GPIO18/GPIO_GEN1), the white wire goes on PIN#06 (Ground).

.Example Python knowledge base - Blinking LED
[source,python]
----
from com.pi4j.io.gpio import RaspiPin, PinState

state = False

class LedBlink(Trigger):
    def onConfigure(self):
        self.event = "blink"
    def onRun(self, event):
        global led, state
        state = not state
        led.setState(state)

def onStartup():
    global led
    led = pi.gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, "led", PinState.LOW)
    EPS.event("blink").sendAfter(0, 1000)

def onShutdown():
    off()

on = lambda: led.setState(True)
off = lambda: led.setState(False)
----

.Example XML configuration
[source,xml]
----
<sponge>
    <properties>
        <!-- Due to the problem https://github.com/Pi4J/pi4j/issues/319, the dynamic linking option is turned on, where Pi4J is dynamically linked
            to WiringPi rather than the default static linking. -->
        <property name="pi4j.linking" system="true">dynamic</property>
    </properties>
    <knowledgeBases>
        <knowledgeBase name="kb">
            <file>pi4j_led_blink.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="pi" class="org.openksavi.sponge.rpi.pi4j.Pi4JPlugin" />
    </plugins>
</sponge>
----

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-rpi-pi4j</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== Raspberry Pi - GrovePi
The GrovePi plugin (`GrovePiPlugin`) allows accessing the https://www.dexterindustries.com/grovepi/[GrovePi] hardware in {sponge} knowledge bases. GrovePi is an electronics board for Raspberry Pi that may have a variety of sensors and actuators connected to. The plugin uses https://github.com/DexterInd/GrovePi/tree/master/Software/Java8[Java 8 GrovePi library]. The current version of the plugin is very simple. For example it hasn't got any configuration parameters.

The default name of the GrovePi plugin (which may be used in knowledge bases) is `grovepi`.

IMPORTANT: If using this plugin in an embedded {sponge}, you have to manually install the https://github.com/DexterInd/GrovePi/tree/master/Software/Java8[Java 8 GrovePi library] in you local Maven repository because it isn't available in the Central Maven Repository.

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/rpi/grovepi/GrovePiPlugin.html[`GrovePiPlugin` Javadoc].

The following example shows how to turn on/off a LED connected to the GrovePi board that in turn is connected to the Raspberry Pi.

.Example Python knowledge base - Blinking LED
[source,python]
----
# GrovePi board: Connect LED to D4

state = False

class LedBlink(Trigger):
    def onConfigure(self):
        self.event = "blink"
    def onRun(self, event):
        global led, state
        state = not state
        led.set(state)

def onStartup():
    global led
    led = grovepi.device.getDigitalOut(4)
    EPS.event("blink").sendAfter(0, 1000)
----

.Example XML configuration
[source,xml]
----
<sponge>
    <knowledgeBases>
        <knowledgeBase name="kb">
            <file>led_blink.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="grovepi" class="org.openksavi.sponge.rpi.grovepi.GrovePiPlugin" />
    </plugins>
</sponge>
----

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-rpi-grovepi</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== ReactiveX
The ReactiveX plugin (`ReactiveXPlugin`) provides support for using http://reactivex.io[ReactiveX] in knowledge bases, e.g. for processing stream of {sponge} events using reactive programming. The plugin uses https://github.com/ReactiveX/RxJava[RxJava library]. The current version of the plugin is very simple. For example it hasn't got any configuration parameters.

The default name of the ReactiveX plugin (which may be used in knowledge bases) is `rx`.

The main object provided by this plugin is an instance of a hot observable (`rx.observable`) that emits all non system {sponge} events. The plugin registers a Java-based correlator that listens to {sponge} events and sends them to the observable.

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/reactivex/ReactiveXPlugin.html[`ReactiveXPlugin` Javadoc].

The following example shows how to use reactive programming in a {sponge} knowledge base.

.Example Python knowledge base - Reactive programming
[source,python]
----
import time
from io.reactivex.schedulers import Schedulers

def onStartup():
    EPS.event("e1").set("payload", 1).send()
    EPS.event("e2").set("payload", 2).sendAfter(500)
    EPS.event("e3").set("payload", 3).sendAfter(1000)

    rx.observable.subscribe(lambda event: EPS.logger.info("{}", event.name))

    def observer(event):
        time.sleep(1)
        EPS.logger.info("After sleep: {}", event.name)
    rx.observable.observeOn(Schedulers.io()).subscribe(observer)
----

.Example XML configuration
[source,xml]
----
<sponge>
    <knowledgeBases>
        <knowledgeBase name="kb">
            <file>reactivex.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="rx" class="org.openksavi.sponge.reactivex.ReactiveXPlugin" />
    </plugins>
</sponge>
----

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-reactivex</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== REST API
The {sponge} REST API provides users a remote access to the key {sponge} functionalities. The REST API plugin (`RestApiPlugin`) uses Apache Camel REST DSL in order to configure the JSON/REST service. After starting the plugin, the online API specification in the https://swagger.io[Swagger] JSON format will be available at URL `http://localhost:1836/api-doc`.

The default name of the REST API plugin (which may be used in knowledge bases) is `restApi`.

.Key REST API plugin configuration parameters
[cols="1,1,4"]
|===
|Name |Type |Description

|`autoStart`
|`boolean`
|If `true` then the REST service will start when the plugin starts up. The default value is `true`.

|`restComponentId`
|`String`
|The Camel REST component id. The default value is `"jetty"`.

|`host`
|`String`
|The REST API host.

|`port`
|`int`
|The REST API port. The default REST API port is `1836`.

|`prettyPrint`
|`boolean`
|The pretty print option.

|`publicActions`
|`List<ProcessorQualifiedName>`
|Public actions.

|`publicEvents`
|`List<String>`
|Public event names.

|`sslConfiguration`
|`SslConfiguration`
|The SSL configuration.

|`publishReload`
|`boolean`
|If `true` then the reload operation will be published. The default value is `true`.

|`routeBuilderClass`
|`String`
|The name of the class extending `RestApiRouteBuilder` (which is the default route builder).

|`apiServiceClass`
|`String`
|The `RestApiService` implementation class name. The default `RestApiService` implementation is `DefaultRestApiService`.

|`securityServiceClass`
|`String`
|The `RestApiSecurityService` implementation class name. The default `RestApiSecurityService` implementation is `NoSecuritySecurityService`.
|===

.The REST API plugin XML configuration example
[source,xml,subs="verbatim,attributes"]
----
<sponge>
    <plugins>
        <plugin name="restApi" class="org.openksavi.sponge.restapi.RestApiPlugin">
            <configuration>
                <port>1836</port>
                <autoStart>false</autoStart>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

.The REST API plugin Java configuration example
[source,java]
----
@Configuration
public static class Config extends SpongeCamelConfiguration {

    @Bean
    public SpongeEngine spongeEngine() {
        return SpringSpongeEngine.builder().plugins(camelPlugin(), restApiPlugin())
                .config("sponge_config.xml").build();
    }

    @Bean
    public RestApiPlugin restApiPlugin() {
        RestApiPlugin plugin = new RestApiPlugin();
        plugin.setService(restApiService());

        return plugin;
    }

    @Bean
    public RestApiService restApiService() {
        RestApiService service = new DefaultRestApiService();
        service.setSecurityService(restApiSecurityService());

        return service;
    }

    @Bean
    public RestApiSecurityService restApiSecurityService() {
        return new SimpleInMemorySecurityService();
    }
}
----

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/restapi/RestApiPlugin.html[`RestApiPlugin` Javadoc].

The REST API plugin provides a simple predefined knowledge base library.

.Example use of the REST API predefined knowledge base library
[source,xml]
----
<knowledgeBase name="security" displayName="Security">
    <file>classpath:org/openksavi/sponge/restapi/restapi_security_library.py</file>
</knowledgeBase>
----

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-rest-api</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== Operations summary
The following table contains a summary of the REST API operations. For a complete list of operations see the <<_swagger_overview, specification>> generated using Swagger and http://swagger2markup.github.io/swagger2markup/1.3.3/[Swagger2Markup].

.The REST API operations summary
[cols="2,1,4"]
|===
|Name |URI |Description

|Get the Sponge version
|`version`
|Returns the Sponge version.

|Get knowledge bases
|`knowledgeBases`
|Returns the knowledge bases.

|Get actions
|`actions`
|Returns the actions.

|Call an action
|`call`
|Calls an action.

|Send a new event
|`send`
|Sends a new event.

|Reload knowledge bases
|`reload`
|Reloads all knowledge bases. This operation may not be published.
|===

.Examples of REST API requests
[source,bash]
----
curl -i -k -X POST -H "Content-type:application/json" http://localhost:1836/sponge.json/v1/version
curl -i -k -X POST -H "Content-type:application/json" http://localhost:1836/sponge.json/v1/knowledgeBases
curl -i -k -X POST -H "Content-type:application/json" http://localhost:1836/sponge.json/v1/actions
curl -i -k -X POST -H "Content-type:application/json" http://localhost:1836/sponge.json/v1/actions -d '{"username":"john","password":"password"}'
curl -i -k -X POST -H "Content-type:application/json" http://localhost:1836/sponge.json/v1/call -d '{"name":"UpperCase","args":["test1","test2", 4]}'
curl -i -k -X POST -H "Content-type:application/json" http://localhost:1836/sponge.json/v1/send -d '{"name":"alarm","attributes":{"a1":"test1","a2":"test2", "a3":4}}'
curl -i -k -X POST -H "Content-type:application/json" http://localhost:1836/sponge.json/v1/reload
----

=== Security
The REST API provides only simple security and only if turned on. All requests allow passing a user name and a password. If the user name is not set, a _guest_ user is assumed. There are three roles: `STANDARD`, `ADMIN` and `GUEST`.

You may set a security strategy by providing an implementation of the `RestApiSecurityService` interface. You may find a few examples of such implementations in the source code. In production mode we suggest using https://spring.io/projects/spring-security[Spring Security] and configure Camel security. An advanced security configuration has to be set up in Java rather than in a {sponge} XML configuration file.

The simple security strategy uses in-memory user data. User privileges and access to knowledge bases, actions and events are verified by calling {sponge} actions (`RestApiIsActionPublic`, `RestApiIsEventPublic`, `RestApiCanUseKnowledgeBase`, `RestApiCanSendEvent`). Passwords are stored as SHA-256 hashes.

.Example of the REST API simple security
[source,python]
----
from org.openksavi.sponge.restapi.security import User

# Simple access configuration role -> knowledge base name regexp.
ROLES_TO_KB = { "admin":".*", "guest":"mpd"}

class RestApiCanUseKnowledgeBase(Action):
    def onCall(self, user, kbName):
        # Defined in the REST API predefined knowledge base library
        return restApiCanUseKnowledgeBase(ROLES_TO_KB, user, kbName)

def onStartup():
    # Set up users. To hash a password use (on Mac): echo -n <username><password> | shasum -a 256 | awk '{ print $1 }'
    # Note that the user name must be lower case.
    securityService = restApi.service.securityService
    securityService.addUser(User("john", "4ae0aa2783d6e8a939b0a3ce8146400001ef6b9840958aea136b416c58a2f9b8", ["admin"]))
    securityService.addUser(User("joe", "e52abe94e1e06f794a3654e02bfbe71565025ea6ce2898d1ad459182f3bc147b", ["guest"]))
----

For more information see examples in the source code.

=== HTTPS
In production mode you should configure HTTPS, preferably using a signed certificate. Otherwise your passwords may be sent in plain text over the network as a part of the REST API JSON requests.

include::sponge-user-guide-rest-api.adoc[leveloffset=+2]
