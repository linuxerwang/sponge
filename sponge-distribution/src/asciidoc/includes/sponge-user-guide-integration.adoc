= Integration

== Spring framework
{sponge} engine may be configured as a Spring bean. That configuration provides standardized access to an embedded {sponge} engine for example in J2EE environment.

To provide access to the Spring `ApplicationContext` in the knowledge base, the `SpringPlugin` instance should be created, *configured as a Spring bean and added to the {sponge} engine*. The Spring plugin shouldn't be defined in {sponge} XML configuration file.

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/spring/SpringPlugin.html[`SpringPlugin` Javadoc].

.Spring Java configuration example
[source,java]
----
@Configuration
public class TestConfig {

    @Bean
    public Engine spongeEngine() { // <1>
        return SpringEngine.builder().plugin(springPlugin()).knowledgeBase("kb", "examples/spring/spring.py").build(); // <2>
    }

    @Bean
    public SpringPlugin springPlugin() { // <3>
        return new SpringPlugin();
    }

    @Bean
    public String testBean() {
        return BEAN_VALUE;
    }
}
----
<1> The engine configured as the Spring bean. The `SpringEngine` implementation is used here in order to startup and shutdown the engine by Spring. `DefaultEngine` could also be used here but it wouldn't provide automatic startup and shutdown.
<2> Added `SpringPlugin`.
<3> `SpringPlugin` configured as the Spring bean.

.Python knowledge base
[source,python]
----
class SpringTrigger(Trigger):
    def onConfigure(self):
        self.event = "springEvent"
    def onRun(self, event):
        beanValue = spring.context.getBean("testBean") # <1>
        self.logger.debug("Bean value = {}", beanValue)
----
<1> A Spring bean named `"testBean"` is acquired from the Spring `ApplicationContext` by using `SpringPlugin` instance referenced by the `spring` variable.

The `SpringEngine` starts up automatically (in the `afterPropertiesSet` Spring callback method) by default. However it may be configured not to start automatically by setting `autoStartup` to `false`.

.SpringEngine not starting automatically example
[source,java]
----
@Bean
public Engine spongeEngine() {
    return SpringEngine.builder().autoStartup(false).plugin(springPlugin()).knowledgeBase("kb", "examples/spring/spring.py").build();
}
----

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml` for this component:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-spring</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== Apache Camel

=== {sponge} Camel component
The *sponge* component provides integration bridge between Apache Camel and the {sponge} engine. It allows:

* to route a body of a Camel message to the {sponge} engine by converting it to a {sponge} event (producer endpoint),
* to route a message from a {sponge} knowledge base to a Camel route (consumer endpoint).

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml` for this component:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-camel</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== URI format
[source,java]
----
sponge:engineRef[?options]
----
Where `engineRef` represents the name of the `Engine` implementation instance located in the Camel registry.

=== Options

[cols="1,2,5"]
|===
|Name |Default value |Description

|`action`
|`"CamelProducerAction"`
|Could be used only on the producer side of the route. It will synchronously call the {sponge} action that has a name specified by the value of this option. However if there is the header named *CamelSpongeAction* in the Camel In message, it would override the value of this option.

|`managed`
|`true`
|If set to `true` the {sponge} engine will be started automatically when the endpoint starts and will be shut down when the endpoint stops.
|===

=== {sponge} support for Camel

==== CamelPlugin
`CamelPlugin` provides an interface to the Camel context so it may be used in a knowledge base. 

`CamelPlugin` may be configured in three different ways.

* Explicitly as a Spring bean and assigned to the engine using the Engine Builder API. This is the preferred way.
+
.Example
[source,python]
----
@Configuration
public class SpringConfiguration extends EngineCamelConfiguration {

    @Bean
    public Engine spongeEngine() {
        return SpringEngine.builder()
                .config("config.xml")
                .plugin(camelPlugin())
                .build();
    }
}
----
* Implicitly when creating a {sponge} Camel endpoint.
* Explicitly in the {sponge} XML configuration file.
+
.Example
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="http://sponge.openksavi.org" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://sponge.openksavi.org http://sponge.openksavi.org/schema/config.xsd">

    <plugins>
        <!-- Note: don't change the plugin name. -->
        <plugin name="camel" class="org.openksavi.sponge.camel.CamelPlugin" />
    </plugins>
</sponge>
----

TIP: If you use an implicit configuration and you get an error stating that `camel` variable is not defined, it signifies that a Camel context is not configured yet or {sponge} engine is not used in any Camel route.

Only one `CamelContext` may be used with one instance of {sponge} engine, bound by a single `CamelPlugin`.

.Important CamelPlugin properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`send(body)`
|Sends the body to all current consumers.

|`send(uri, body)`
|Sends the body to an endpoint.

|`request(uri, body)`
|Sends the body to an endpoint returning any result output body.

|`getContext()`
|Returns a Camel context.

|`getConsumers()`
|Returns the current list of consumers.
|===

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/camel/CamelPlugin.html[`CamelPlugin` Javadoc].


==== Spring-based support
`EngineCamelConfiguration` provides base Camel and {sponge} configuration using Spring Java configuration. Your Spring configuration could inherit from this class.

Spring bean named `"spongeProducerTemplate"` allows you to configure a Camel producer template used by `CamelPlugin` to send Camel messages. If none is present in a Spring configuration, then a default will be used.

Spring bean named `springPlugin` is the instance of `SpringPlugin` that could be registered in the engine and used in knowledge bases as the `spring` variable.

Spring bean named `camelPlugin` is the instance of `CamelPlugin` that could be registered in the engine and used in knowledge bases as the `camel` variable.

=== Producer
Using sponge component on the producer side of the route will forward a body of a Camel message to the specified {sponge} engine.

{sponge} in a producer mode could be placed in many routes in one Camel context.

.Producer example - Spring configuration
[source,java]
----
@Configuration
public class ExampleConfiguration extends EngineCamelConfiguration {

    @Bean
    public Engine spongeEngine() {
        // Use EngineBuilder API to create an engine. Also bind Spring and Camel plugins as beans manually.
        return SpringEngine.builder()
                .knowledgeBase("camelkb", "examples/camel/camel_producer.py")
                .plugins(springPlugin(), camelPlugin())
                .build();
    }

    @Bean
    public RouteBuilder exampleRoute() {
        return new RouteBuilder() {
            @Override
            public void configure() {
                from("direct:start").routeId("spongeProducer")
                    .to("sponge:spongeEngine");
            }
        };
    }
}
----

.Python knowledge base `camel_producer.py`
[source,python]
----
class CamelTrigger(Trigger):
    def onConfigure(self):
        self.event = "spongeProducer"
    def onRun(self, event):
        print event.body
----

.Producer example - Sample code that sends a Camel message
[source,java]
----
// Starting a Spring context.
GenericApplicationContext context = new AnnotationConfigApplicationContext(ExampleConfiguration.class);
context.start();

// Sending a Camel message.
CamelContext camel = context.getBean(CamelContext.class);
ProducerTemplate producerTemplate = camel.createProducerTemplate();
producerTemplate.sendBody("direct:start", "Send me to the Sponge");

// Waiting for the engine to process an event.
----

.Output console
[source,bash,subs="verbatim,attributes"]
----
Send me to the Sponge
----

==== Camel producer action
Camel producer action will be invoked by {sponge} synchronously when a Camel exchange comes to the {sponge} engine. The result returned by this action is placed as the body of the Camel _IN_ message. So it may be used by the next endpoint in the route if there is any.

NOTE: To avoid misconception please note that events in the Output Event Queue are not sent to the Camel route.

===== Default Camel producer action
The default Camel producer action is provided by a Java action `CamelProducerAction`. If the body of the Camel message is a {sponge} event or event definition, than the event is sent to the {sponge} immediately. Otherwise this action creates and sends a new event that encapsulates the body. The event is then returned, so it is placed as the body of the Camel In message. The default name of the new event is the name of the corresponding Camel route.

===== Custom Camel producer action
You could provide a custom implementation of a Camel producer action in two ways:

* define your own implementation of `CamelProducerAction` in a knowledge base,
* define an action in a knowledge base that takes an array that contains a single element of the class `Exchange` and specify it in the producer endpoint URI or in the message header, e.g.:
+
.Python knowledge base
[source,python]
----
class CustomAction(Action):
    def onCall(self, args):
        exchange = args[0]
        return "OK"
----
+
.Camel route that sets the action in the endpoint URI
[source,java]
----
from("direct:start").routeId("spongeProducer")
        .to("sponge:spongeEngine?action=CustomAction")
        .log("Action result as a body: ${body}");
----
+
.Camel route that sets the action in the header
[source,java]
----
from("direct:start").routeId("spongeProducer")
        .setHeader("CamelSpongeAction", constant("CustomAction"))
        .to("sponge:spongeEngine)
        .log("Action result as a body: ${body}");
----

=== Consumer
Using sponge component on the consumer side of the route will forward messages sent from the specified {sponge} engine to a Camel route.

{sponge} in a consumer mode could be placed in many routes in one Camel context.

.Consumer example - Spring configuration
[source,java]
----
@Configuration
public class ExampleConfiguration extends EngineCamelConfiguration {

    @Bean
    public Engine spongeEngine() {
        // Use EngineBuilder API to create an engine. Also bind Spring and Camel plugins as beans manually.
        return SpringEngine.builder()
                .knowledgeBase("camelkb", "examples/camel/camel_consumer.py")
                .plugins(springPlugin(), camelPlugin())
                .build();
    }

    @Bean
    public RouteBuilder exampleRoute() {
        return new RouteBuilder() {

            @Override
            public void configure() {
                from("sponge:spongeEngine").routeId("spongeConsumer")
                    .log("${body}")
                    .to("stream:out");
            }
        };
    }
}
----

.Python knowledge base `camel_simple_consumer.py`
[source,python]
----
class CamelTrigger(Trigger):
    def onConfigure(self):
        self.event = "spongeEvent"
    def onRun(self, event):
        camel.send(event.get("message"))

def onStartup():
    # Add a delay to allow starting of Camel, if necessary. This requirement depends on the configuration
    # of Sponge and Camel in Spring.
    EPS.event("spongeEvent").set("message", "Send me to Camel").sendAfter(1000)
----

The variable `camel` is a reference to the instance of `CamelPlugin` that is associated with the Camel context.

.Output console
[source,bash,subs="verbatim,attributes"]
----
Send me to Camel
----

You may also send a message to the Camel endpoint directly, e.g.:
[source,python]
----
camel.send("direct:log", event.get("message"))
----
This allows you, for example, to create a flexible message flow using Camel routes and {sponge} as a dispatcher.

=== Routes in scripting languages
`ScriptRouteBuilder` class introduces `fromS` methods (meaning _from Script_) that delegate to the corresponding `from` methods in order to avoid using `from` since it could be a reserved keyword in scripting languages (e.g. in Python). So when defining Camel routes in Python you should use this class instead of standard `RouteBuilder`, e.g.:

[source,python]
----
from org.openksavi.sponge.camel import ScriptRouteBuilder

class PythonRoute(ScriptRouteBuilder):
    def configure(self):
        self.fromS("sponge:spongeEngine").routeId("spongeConsumerCamelPython") \
                .transform().simple("${body}") \
                .process(lambda exchange: EPS.getVariable("receivedRssCount").incrementAndGet()) \
                .to("stream:out")

def onStartup():
    camel.context.addRoutes(PythonRoute())
----

== Python (CPython)
{sponge} may communicate with external programs written in the reference implementation of the Python programming language - https://en.wikipedia.org/wiki/CPython[CPython] using https://www.py4j.org[Py4J], and vice versa. A Python program and a {sponge} Java process communicate through network sockets.

Py4J by default uses the TCP port 25333 to communicate from Python to Java and TCP port 25334 to communicate from Java to Python.

There is no support for writing knowledge bases in CPython.

The CPython environment must have Py4J installed, e.g.:

[source,bash]
----
pip install py4j
----

For more information on Py4J see https://www.py4j.org/advanced_topics.html.

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-py4j</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== Py4J plugins

{sponge} provides two plugins for integration with CPython.

WARNING: Local network sockets used by Py4j should be secured, for example using [https://www.py4j.org/advanced_topics.html#tls]TLS. Please be aware that all {sponge} operations are accessible in other processes that communicate with the {sponge} with Py4J enabled by a plugin. See {py4jSourcesUrl}/java_server_tls for an example of TLS security, based on Py4J examples. Note that in a production environment you should customize this simple configuration, possibly by providing your own configured instance of `GatewayServer` or `ClientServer` to the plugin.

.Py4J plugin common configuration parameters
[cols="1,1,4"]
|===
|Name |Type |Description

|`facadeInterface`
|`String`
|A Java interface that is a facade to the Py4J entry point object configured on the CPython side.

|`javaPort`
|`Integer`
|Java side server port.

|`pythonPort`
|`Integer`
|CPython side server port.

|`security/keystore`
|`String`
|Simple security keystore file location on the classpath.

|`security/password`
|`String`
|Simple security keystore password.

|`security/algorithm`
|`String`
|Simple security algorithm. The default value is `SunX509`.
|===

==== GatewayServerPy4JPlugin

`GatewayServerPy4JPlugin` provides integration with CPython using Py4J `GatewayServer`.

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/py4j/GatewayServerPy4JPlugin.html[`GatewayServerPy4JPlugin` Javadoc].

[discrete]
===== {sponge} side example

.GatewayServerPy4JPlugin XML configuration example
[source,xml,subs="verbatim,attributes"]
----
<sponge>
    <plugins>
        <plugin name="py4j" class="org.openksavi.sponge.py4j.GatewayServerPy4JPlugin" />
    </plugins>
</sponge>
----

[discrete]
===== CPython side example

.Sending {sponge} event in CPython
[source,python]
----
from py4j.java_gateway import JavaGateway

gateway = JavaGateway()

# EPS in other process accessed via Py4J
EPS = gateway.entry_point

print "Connected to {}".format(EPS.getDescription())
EPS.event("helloEvent").set("say", "Hello from Python's Py4J").send()
----

Note that a simplified bean property access is not supported here. So instead of `EPS.description` you have to invoke `EPS.getDescription()`.

==== ClientServerPy4JPlugin

`ClientServerPy4JPlugin` provides integration with CPython using Py4J `ClientServer`.

.ClientServerPy4JPlugin plugin specific configuration parameters
[cols="1,1,4"]
|===
|Name |Type |Description

|`autoStartJavaServer`
|`Boolean`
|Auto start of Py4J JavaServer.
|===

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/py4j/ClientServerPy4JPlugin.html[`ClientServerPy4JPlugin` Javadoc].

[discrete]
===== {sponge} side example

.ClientServerPy4JPlugin XML configuration example
[source,xml,subs="verbatim,attributes"]
----
<sponge>
    <plugins>
        <plugin name="py4j" class="org.openksavi.sponge.py4j.ClientServerPy4JPlugin">
            <configuration>
                <facadeInterface>org.openksavi.sponge.py4j.PythonService</facadeInterface>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

.Python facade interface
[source,java]
----
public interface PythonService {
    String toUpperCase(String text);
}
----

.ClientServerPy4JPlugin knowledge base example written in Jython
[source,python]
----
# Note that this code is interpreted by Jython in Sponge, not CPython
class PythonUpperCase(Action):
    def onCall(self, args):
        result = py4j.facade.toUpperCase(args[0])
        self.logger.debug("CPython result for {} is {}", args[0], result)
        return result
----

[discrete]
===== CPython side example

.Implementation of the facade interface in CPython
[source,python]
----
from py4j.clientserver import ClientServer

class PythonService(object):
    def toUpperCase(self, text):
        return text.upper()
    class Java:
        implements = ["org.openksavi.sponge.py4j.PythonService"]

pythonService = PythonService()
gateway = ClientServer(python_server_entry_point=pythonService)
----

== MIDI
The MIDI plugin (`MidiPlugin`) allows processing https://en.wikipedia.org/wiki/MIDI[MIDI] messages by the {sponge} and provides communication with MIDI devices. It wraps MIDI messages in {sponge} events. The plugin supports `ShortMessage`, `MetaMessage` and `SysexMessage` MIDI messages wrapping them respectively in `MidiShortMessageEvent`, `MidiMetaMessageEvent` and `MidiSysexMessageEvent` {sponge} events. Although the MIDI support in the {sponge} provides a set of methods that use the `javax.sound.midi` API, the goal of this plugin is not to be a complete interface to the MIDI system but a bridge between MIDI messages and {sponge} events.

The default name of the MIDI plugin (which may be used in knowledge bases) is `midi`.

.MIDI plugin configuration parameters
[cols="1,1,4"]
|===
|Name |Type |Description

|`sequencerConnectedToSynthesizer`
|`Boolean`
|If `true` then the default MIDI sequencer will be connected to the default synthesizer (e.g. to generate sound while playing MIDI files). The default value is `false`.

|`loadAllInstruments`
|`Boolean`
|If `true` then all instruments in the default soundbank will be loaded at startup. The default value is `true`.

|`midiShortMessageEventName`
|`String`
|A name of a MIDI ShortMessage {sponge} event sent by this plugin to the engine. The default value is `"midiShort"`.

|`midiMetaMessageEventName`
|`String`
|A name of a MIDI MetaMessage {sponge} event sent by this plugin to the engine. The default value is `"midiMeta"`.

|`midiSysexMessageEventName`
|`String`
|A name of a MIDI SysexMessage {sponge} event sent by this plugin to the engine. The default value is `"midiSysex"`.
|===

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/midi/MidiPlugin.html[`MidiPlugin` Javadoc].

.Example Python knowledge base that shows how to process MIDI messages created by an external MIDI input device
[source,python]
----
from javax.sound.midi import ShortMessage
from org.openksavi.sponge.midi import MidiUtils

class SameSound(Trigger):
    def onConfigure(self):
        self.event = "midiShort" # <1>
    def onRun(self, event):
        midi.sound(event.message) # <2>

class Log(Trigger):
    def onConfigure(self):
        self.event = "midiShort"
    def onRun(self, event):
        self.logger.info("{}Input message: {}", "[" + MidiUtils.getKeyNote(event.data1) + "] " if event.command == ShortMessage.NOTE_ON else "",
                         event.messageString) # <3>

def onStartup():
    EPS.logger.info("This example program enables a user to play an input MIDI device (e.g. a MIDI keyboard) using the Sponge MIDI plugin.")
    midi.connectDefaultInputDevice() # <4>
    EPS.logger.info("Input MIDI device: {}", midi.inputDevice.deviceInfo.name)
    EPS.logger.info("Instruments: {}", ",".join(list(map(lambda i: i.name + " (" + str(i.patch.bank) + "/" + str(i.patch.program) + ")", midi.instruments))))
    midi.setInstrument(0, "Electric Piano 1") # <5>
----
<1> The trigger `SameSound` listens to all MIDI short messages.
<2> The trigger `SameSound` sends all MIDI short messages received from the input MIDI device to the MIDI synthesizer to generate sounds. It is achieved through the use of the `sound` method in the `midi` plugin.
<3> The trigger `Log` only logs a MIDI message info and a note for _note on_ MIDI messages.
<4> Connects a default input MIDI device in the system (e.g. a MIDI keyboard) to the MIDI plugin in order to receive all MIDI messages generated by this device and send them to the {sponge} engine as {sponge} events.
<5> Sets the instrument (by name) in the MIDI synthesizer for the MIDI channel `0`. Note that this example assumes that the input MIDI device will generate MIDI messages for the same channel.

NOTE: An event flow in the {sponge} engine introduces an additional performance overhead that in some situations may be not acceptable when dealing with real-time physical MIDI instruments.

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-midi</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== MPD
The MPD plugin (`MpdPlugin`) provides integration with an https://en.wikipedia.org/wiki/Music_Player_Daemon[MPD (Music Player Daemon)] server.

NOTE: The plugin is located in the `sponge-mpd` {sponge} external module. The reason that the MPD support is located in the external {sponge} module is that *it is released under http://www.gnu.org/copyleft/gpl.html[GNU GPL Version 3] license* which is not compatible with the {sponge} Apache 2.0 license. This requirement is forced by the license of the underlying library https://github.com/finnyb/javampd[JavaMPD].

The default name of the MPD plugin (which may be used in knowledge bases) is `mpd`.

.MPD plugin configuration parameters
[cols="1,1,4"]
|===
|Name |Type |Description

|`hostname`
|`String`
|The MPD server hostname.

|`port`
|`Integer`
|The MPD server port.

|`password`
|`String`
|The MPD server password.

|`timeout`
|`Integer`
|The MPD server timeout.

|`eventNamePrefix`
|`String`
|The MPD-based Sponge event name prefix. The default value is `"mpd"`.

|`autoConnect`
|`Boolean`
|The auto connect flag. If `true` (the default value), the plugin connects to the MPD server on startup.
|===

For more information see the {spongeJavaDocUrl}/org/openksavi/sponge/mpd/MpdPlugin.html[`MpdPlugin` Javadoc] and http://finnyb.github.io/javampd/[JavaMPD].

The following example searches for albums in the MPD database matching the given criteria and adds them to the playlist.

.Example Python knowledge base
[source,python]
----
def selectAlbums(albums, yearMin, yearMax, genreRegexp):
    selectedAlbums = []
    for album in albums:
        if album.date and album.date >= str(yearMin) and album.date <= str(yearMax) and album.genre and re.match(genreRegexp.lower(), album.genre.lower()):
            selectedAlbums.append(album)
    return selectedAlbums

def setAndPlayPlaylist(albums):
    if len(albums) == 0:
        return
    mpd.server.playlist.clearPlaylist() # <1>
    mpd.server.playlist.insertAlbum(albums[0])
    # Play immediately after inserting the first album
    mpd.server.player.play()
    for album in albums[1:]:
        mpd.server.playlist.insertAlbum(album) 

def onStartup():
    albums = mpd.server.musicDatabase.albumDatabase.listAllAlbums()
    EPS.logger.info("MPD server version: {}. All album count: {}", mpd.server.version, len(albums))

    EPS.logger.info("Setting the playlist...")
    # Set the playlist to rock albums released since 1970 
    selectedAlbums = selectAlbums(albums, 1970, 2018, ".*(Rock).*")
    if len(selectedAlbums) > 0:
        setAndPlayPlaylist(selectedAlbums)
        EPS.logger.info("The playlist is set, {} albums found", len(selectedAlbums))
    else:
        EPS.logger.info("No matching albums found")
----
<1> The `mpd.server` is a reference to the instance of the `MPD` class (part of JavaMPD library) which represents a connection to a MPD server.

=== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-mpd</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

