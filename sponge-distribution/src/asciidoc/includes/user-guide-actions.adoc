= Actions
Actions provide functionality similar to synchronous functions. They may be used in many knowledge bases that are written in different languages.

The alias for the base class for script-based actions is `Action`. The base class for Java-based actions is `JAction`.

== Properties and methods
In addition to the inherited <<processor-methods,processor properties and methods>>, actions provide the following ones.

.Action properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`Object onCall(_dynamic arguments_)`
|The dynamic callback method that should be defined in an action. It will be invoked when an action is called, e.g.: `sponge.call(actionName, [argument list])`. The behavior of this method is dynamic, i.e. custom actions define `onCall` methods with the arbitrary number of named arguments, for example `def onCall(self, value, text)`. This is the reason that the `Action` interface doesn't force any implementation of `onCall`. The result is an `Object`. The implementation of this method is mandatory.

|`void onProvideArgs(Set<String> names, Map<String, Object> current, Map<String, ArgValue> provided)`
|A callback method that returns the provided argument values along with argument value sets (i.e. possible values of an argument). The provided arguments are explained later in this document.
|===

The `onConfigure` method in actions is not mandatory.

[discrete]
== Example in a script language
The code presented below defines the action named `EchoAction` that simply returns all arguments.

.Action example
[source,python]
----
class EchoAction(Action): # <1>
    def onCall(self, text): # <2>
        return text

def onStartup():
    result = sponge.call("EchoAction", ["test"]) # <3>
    logger.debug("Action returned: {}", result)
----
<1> The definition of the action `EchoAction`. The action is represented by the class of the same name.
<2> The action `onCall` dynamic callback method that takes one argument `text`.
<3> Calls the action named `"EchoAction"` passing one argument.

.Console output
----
Action returned: test
----

[discrete]
== Example in Java
The code presented below defines the Java-based action named `JavaEchoAction`.

.Java action example
[source,java]
----
public class JavaEchoAction extends JAction { // <1>

    @Override
    public Object onCall(String text) { // <2>
        return text;
    }
}
----
<1> The definition of the action `JavaEchoAction`. The action is represented by the Java class of the same name.
<2> The action `onCall` callback method.

.Java action manual registration in the Python knowledge base
[source,python]
----
sponge.enableJava(JavaEchoAction)
----

== Arguments and result metadata
Actions may have metadata specified in the `onConfigure` method. Metadata may describe action arguments and a result. Metadata are not verified by the engine while performing an action call but could be interpreted by a client code or {sponge} plugins. For example they could be useful in a generic GUI that calls {sponge} actions. Metadata can be specified using the builder-style methods.

Metadata for arguments and a result support <<types, types>>.

.Argument metadata properties
[cols="1,3"]
|===
|Property |Description

|`name`
|A mandatory argument name.

|`type`
|A mandatory argument type.

|`label`
|An optional argument label.

|`description`
|An optional argument description.

|`optional`
|A not mandatory flag specifying if this argument is optional. Defaults to `false`. Optional arguments can be specified only as last in the argument list. Optional arguments are not required to be passed when calling an action.

|`provided`
|The _provided_ argument specification as an instance of the `ArgProvided` class. Defaults to `null`.
|===

.Provided argument specification properties
[cols="1,3"]
|===
|Property |Description

|`value`
|A flag specifying if this argument value is provided.

|`valueSet`
|The flag specifying if this argument value set is provided.

|`depends`
|A list of attribute names that this attribute depends on.

|`readOnly`
|A flag specifying if this argument is read only. Defaults to `false`.

|`overwrite`
|A flag specifying if the provided value of this argument should overwrite the value set in a client code. Defaults to `false`. This flag should be handled by a client code.
|===

.Result metadata properties
[cols="1,3"]
|===
|Property |Description

|`type`
|A mandatory result type.

|`label`
|An optional result label.

|`description`
|An optional result description.
|===

.Action metadata example
[source,python]
----
class UpperCase(Action):
    def onConfigure(self):
        self.label = "Convert to upper case"
        self.description = "Converts a string to upper case."
        self.features = {"visibility":True}
        self.argsMeta = [
            ArgMeta("text", StringType()).withLabel("Text to upper case").withDescription("The text that will be converted to upper case."),
            ArgMeta("optionalText", AnyType().withNullable(True)).withLabel("Text suffix").withOptional()
        ]
        self.resultMeta = ResultMeta(StringType()).withLabel("Upper case text")
    def onCall(self, text, optionalText = None):
        return text.upper() + ( " " + optionalText.upper() if optionalText is not None else "")
----

.Action metadata example with multiple arguments
[source,python]
----
class MultipleArgumentsAction(Action):
    def onConfigure(self):
        self.label = "Multiple arguments action"
        self.argsMeta = [
            ArgMeta("stringArg", StringType().withMaxLength(10).withFormat("ipAddress")),
            ArgMeta("integerArg", IntegerType().withMinValue(1).withMaxValue(100).withDefaultValue(50)),
            ArgMeta("anyArg", AnyType().withNullable(True)),
            ArgMeta("stringListArg", ListType(StringType())),
            ArgMeta("decimalListArg", ListType(ObjectType("java.math.BigDecimal"))),
            ArgMeta("stringArrayArg", ObjectType("java.lang.String[]")),
            ArgMeta("javaClassArg", ObjectType("org.openksavi.sponge.examples.CustomObject")),
            ArgMeta("javaClassListArg", ListType(ObjectType("org.openksavi.sponge.examples.CustomObject"))),
            ArgMeta("binaryArg", BinaryType().withMimeType("image/png").withFeatures({"width":28, "height":28, "color":"white"})),
        ]
        self.resultMeta = ResultMeta(BooleanType()).withLabel("Boolean result")
    def onCall(self, stringArg, integerArg, anyArg, stringListArg, decimalListArg, stringArrayArg, javaClassArg, javaClassListArg, binaryArg):
        return True
----

.Action metadata using the builder-style methods
[source,python]
----
class UpperEchoAction(Action):
    def onConfigure(self):
        self.withLabel("Echo Action").withDescription("Returns the upper case string").withArgsMeta([
            ArgMeta("text", StringType()).withLabel("Argument 1").withDescription("Argument 1 description")
        ]).withResultMeta(ResultMeta(StringType()).withLabel("Upper case string").withDescription("Result description"))
    def onCall(self, text):
        return self.label + " returns: " + text.upper()
----

For more information see `ArgMeta` and `ResultMeta`.

== Provided arguments
An action argument can be _provided_, i.e. its value and possible value set may be computed and returned to a client code every time before calling an action. A provided argument gives more flexibility than the `defaultValue` in the argument data type.

This feature makes easier creating a generic UI for an action call that reads and presents the actual state of the entities that are to be changed or only viewed by the action and its arguments.

.Example of an action with provided arguments
[source,python]
----
def onInit():
    sponge.setVariable("actuator1", "A")
    sponge.setVariable("actuator2", False)
    sponge.setVariable("actuator3", 1)
    sponge.setVariable("actuator4", 1)
    sponge.setVariable("actuator5", "X")

class SetActuator(Action):
    def onConfigure(self):
        self.label = "Set actuator"
        self.description = "Sets the actuator state."
        self.argsMeta = [
            ArgMeta("actuator1", StringType()).withLabel("Actuator 1 state").withProvided(ArgProvidedMeta().withValue().withValueSet()),
            ArgMeta("actuator2", BooleanType()).withLabel("Actuator 2 state").withProvided(ArgProvidedMeta().withValue()),
            ArgMeta("actuator3", IntegerType().withNullable()).withLabel("Actuator 3 state").withProvided(ArgProvidedMeta().withValue().withReadOnly()),
            ArgMeta("actuator4", IntegerType()).withLabel("Actuator 4 state"),
            ArgMeta("actuator5", StringType()).withLabel("Actuator 5 state").withProvided(ArgProvidedMeta().withValue().withValueSet().withDepends("actuator1")),
        ]
        self.resultMeta = ResultMeta(VoidType())
    def onCall(self, actuator1, actuator2, actuator3, actuator4, actuator5):
        sponge.setVariable("actuator1", actuator1)
        sponge.setVariable("actuator2", actuator2)
        # actuator3 is read only in this action.
        sponge.setVariable("actuator4", actuator4)
        sponge.setVariable("actuator5", actuator5)
    def onProvideArgs(self, names, current, provided):
        if "actuator1" in names:
            provided["actuator1"] = ArgProvidedValue().withValue(sponge.getVariable("actuator1", None)).withAnnotatedValueSet(
                [AnnotatedValue("A").withLabel("Value A"), AnnotatedValue("B").withLabel("Value B"), AnnotatedValue("C").withLabel("Value C")])
        if "actuator2" in names:
            provided["actuator2"] = ArgProvidedValue().withValue(sponge.getVariable("actuator2", None))
        if "actuator3" in names:
            provided["actuator3"] = ArgProvidedValue().withValue(sponge.getVariable("actuator3", None))
        if "actuator5" in names:
            provided["actuator5"] = ArgProvidedValue().withValue(sponge.getVariable("actuator5", None)).withValueSet(["X", "Y", "Z", current["actuator1"]])

def onStartup():
    sponge.logger.debug("The provided value of actuator1 is: {}", sponge.provideActionArgs("SetActuator", ["actuator1"])["actuator1"].getValue())
----

.Console output
----
The provided value of actuator1 is: A
----

A provided argument can be `readOnly`. In that case its value in the `onCall` method should be ignored. A read only argument type has to be nullable.

A provided argument can _depend_ on other arguments but only those that are specified earlier. In the example argument `actuator5` depends on `actuator1`. Its possible value set contains the value of `actuator1`.

Arguments configured as provided have to be calculated in the `onProvideArgs` callback method and set in the `provided` map. For each provided argument its value and possible value set can be produced as the instance of the `ArgValue` class. The optional `withValue` method sets the provided value. The optional `withAnnotatedValueSet` method sets the value set along with annotations (e.g. labels) where each element is an instance of the `AnnotatedValue` class. The optional `withValueSet` method sets the possible value set with no annotations.

The parameter `names` in the `onProvideArgs` is a set of argument names that are to be provided. The `current` parameter is a not null map of argument names and their current values passed from a client code. The current value means the value used in a client code, for example entered by a user into an UI before calling the action. This map is required to contain values of those arguments that the arguments specified in the `names` depend on.

== Implementing interfaces
Actions may implement additional Java interfaces. It could be used to provide custom behavior of actions.

.Action implementing a Java interface
[source,python]
----
from org.openksavi.sponge.integration.tests.core import TestActionVisibiliy

class EdvancedAction(Action, TestActionVisibiliy): # <1>
    def onCall(self, text):
        return text.upper()
    def isVisible(self, context):
        return context == "day"
----
<1> The Java interface `TestActionVisibiliy` declares only one method `boolean isVisible(Object context)`.

