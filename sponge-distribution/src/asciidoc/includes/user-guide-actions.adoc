= Actions
Actions provide functionality similar to synchronous functions. They may be used in many knowledge bases that are written in different languages.

The alias for the base class for script-based actions is `Action`. The base class for Java-based actions is `JAction`.

== Properties and methods
In addition to the inherited <<processor-methods,processor properties and methods>>, actions provide the following ones.

.Action properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`withArgs(List<DataType> argTypes)`
|Sets action arguments metadata as data types. The action argument types can be read using `self.meta.args`. Each argument data type must have a name. The same name should be used as a name of a corresponding argument in an `onCall` method. Arguments that have the `optional` flag set in their type are optional. Optional arguments can be specified only as last in the argument list and are not required to be passed when calling an action.

|`withArg(DataType argType)`
|Sets a single action argument metadata as a type.

|`withNoArgs()`
|Defines that an action has no arguments.

|`withResult(DataType resultType)`
|Sets an action result type. The action result type can be read using `self.meta.result`.

|`withNoResult()`
|Defines that an action has no result, i.e. it's result is of `VoidType`.

|`withCallable(boolean callable)`
|Sets a callable flag for the action. A callable action must have an `onCall` method defined. Defaults to `true`. The reason an action would be not callable is if it is used with provided arguments.

|`Object onCall(_dynamic arguments_)`
|A dynamic callback method that should be defined in a callable action. It will be invoked when an action is called, e.g.: `sponge.call(actionName, [argument list])`. The behavior of this method is dynamic, i.e. custom actions define `onCall` methods with the arbitrary number of named arguments, for example `def onCall(self, value, text)`. This is the reason that the `Action` interface doesn't force any implementation of `onCall`. The result is an `Object`.

|`void onProvideArgs(ProvideArgsContext context)`
|A callback method that provides argument values along with argument value sets (i.e. possible values of an argument). The provided arguments are explained later in this document.
|===

The `onConfigure` method in actions is not mandatory.

[discrete]
== Example in a script language
The code presented below defines the action named `EchoAction` that simply returns all arguments.

.Action example
[source,python]
----
class EchoAction(Action): # <1>
    def onCall(self, text): # <2>
        return text

def onStartup():
    result = sponge.call("EchoAction", ["test"]) # <3>
    logger.debug("Action returned: {}", result)
----
<1> The definition of the action `EchoAction`. The action is represented by the class of the same name.
<2> The action `onCall` dynamic callback method that takes one argument `text`.
<3> Calls the action named `"EchoAction"` passing one argument.

.Console output
----
Action returned: test
----

[discrete]
== Example in Java
The code presented below defines the Java-based action named `JavaEchoAction`.

.Java action example
[source,java]
----
public class JavaEchoAction extends JAction { // <1>

    @Override
    public Object onCall(String text) { // <2>
        return text;
    }
}
----
<1> The definition of the action `JavaEchoAction`. The action is represented by the Java class of the same name.
<2> The action `onCall` callback method.

.Java action manual registration in the Python knowledge base
[source,python]
----
sponge.enableJava(JavaEchoAction)
----

== Arguments and result metadata
Actions may have metadata specified in the `onConfigure` method. Metadata may describe action arguments and a result. Metadata are not verified by the engine while performing an action call but could be interpreted by a client code or {sponge} plugins. For example they could be useful in a generic GUI that calls {sponge} actions. Metadata can be specified using the builder-style methods.

Metadata for arguments and a result are specified by <<types, types>>.

.Action metadata example
[source,python]
----
class UpperCase(Action):
    def onConfigure(self):
        self.withLabel("Convert to upper case").withDescription("Converts a string to upper case.")
        self.withArg(
            StringType("text").withMaxLength(256).withLabel("Text to upper case").withDescription("The text that will be converted to upper case.")
        )
        self.withResult(StringType().withLabel("Upper case text"))
    def onCall(self, text):
        return text.upper()
----

.Action metadata example with multiple arguments
[source,python]
----
class MultipleArgumentsAction(Action):
    def onConfigure(self):
        self.withLabel("Multiple arguments action").withDescription("Multiple arguments action.")
        self.withArgs([
            StringType("stringArg").withMaxLength(10).withFormat("ipAddress"),
            IntegerType("integerArg").withMinValue(1).withMaxValue(100).withDefaultValue(50),
            AnyType("anyArg").withNullable(),
            ListType("stringListArg", StringType()),
            ListType("decimalListArg", ObjectType().withClassName("java.math.BigDecimal")),
            ObjectType("stringArrayArg").withClassName("java.lang.String[]"),
            ObjectType("javaClassArg").withClassName("org.openksavi.sponge.examples.CustomObject"),
            ListType("javaClassListArg", ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject")),
            BinaryType("binaryArg").withMimeType("image/png").withFeatures({"width":28, "height":28, "background":"black", "color":"white"}),
            TypeType("typeArg"),
            DynamicType("dynamicArg")
        ])
        self.withResult(BooleanType().withLabel("Boolean result"))
    def onCall(self, stringArg, integerArg, anyArg, stringListArg, decimalListArg, stringArrayArg, javaClassArg, javaClassListArg, binaryArg, typeArg, dynamicArg):
        return True
----

.Action metadata using the fluent builder-style methods
[source,python]
----
class UpperEchoAction(Action):
    def onConfigure(self):
        self.withLabel("Echo Action").withDescription("Returns the upper case string").withArg(
            StringType("text").withLabel("Argument 1").withDescription("Argument 1 description")
        ).withResult(StringType().withLabel("Upper case string").withDescription("Result description"))
    def onCall(self, text):
        return self.meta.label + " returns: " + text.upper()
----

[[provided_arguments]]
== Provided arguments
An action argument can be _provided_, i.e. its value and possible value set may be computed and returned to a client code any time before calling an action. A provided argument gives more flexibility than the `defaultValue` in the argument data type. Nested values of action arguments can be provided as well. In that case both a type being provided and a dependency path have to be named and can't contain collections (lists or maps) as intermediate path elements.

The `onProvideArgs(ProvideArgsContext context)` method is used to provide action argument values.

.`ProvideArgsContext` properties
[cols="1,3"]
|===
|Property |Description

|`Set<String> names`
|A not null set of argument names (or name paths) that are to be provided. A name path is a dot-separated sequence of names of parent types, e.g. `"book.author.surname"`.

|`Map<String, Object> current`
|The not null map of argument names (or name paths) and their current values passed from a client code. The map is required to contain values of those arguments that the arguments specified in the `names` depend on.

|`Map<String, ProvidedValue> provided`
|An initially empty map of argument names (or name paths) and their provided values (value sets) that is to be set up in an `onProvideArgs` callback method implementation.
|===

This feature makes easier creating a generic UI for an action call that reads and presents the actual state of the entities that are to be changed or only viewed by the action and its arguments.

.Example of an action with provided arguments
[source,python]
----
def onInit():
    sponge.setVariable("actuator1", "A")
    sponge.setVariable("actuator2", False)
    sponge.setVariable("actuator3", 1)
    sponge.setVariable("actuator4", 1)
    sponge.setVariable("actuator5", "X")

class SetActuator(Action):
    def onConfigure(self):
        self.withLabel("Set actuator").withDescription("Sets the actuator state.")
        self.withArgs([
            StringType("actuator1").withLabel("Actuator 1 state").withProvided(ProvidedMeta().withValue().withValueSet()),
            BooleanType("actuator2").withLabel("Actuator 2 state").withProvided(ProvidedMeta().withValue()),
            IntegerType("actuator3").withNullable().withLabel("Actuator 3 state").withProvided(ProvidedMeta().withValue().withReadOnly()),
            IntegerType("actuator4").withLabel("Actuator 4 state"),
            StringType("actuator5").withLabel("Actuator 5 state").withProvided(ProvidedMeta().withValue().withValueSet().withDependency("actuator1"))
        ]).withNoResult()
    def onCall(self, actuator1, actuator2, actuator3, actuator4, actuator5):
        sponge.setVariable("actuator1", actuator1)
        sponge.setVariable("actuator2", actuator2)
        # actuator3 is read only in this action.
        sponge.setVariable("actuator4", actuator4)
        sponge.setVariable("actuator5", actuator5)
    def onProvideArgs(self, context):
        if "actuator1" in context.names:
            context.provided["actuator1"] = ProvidedValue().withValue(sponge.getVariable("actuator1", None)).withAnnotatedValueSet(
                [AnnotatedValue("A").withLabel("Value A"), AnnotatedValue("B").withLabel("Value B"), AnnotatedValue("C").withLabel("Value C")])
        if "actuator2" in context.names:
            context.provided["actuator2"] = ProvidedValue().withValue(sponge.getVariable("actuator2", None))
        if "actuator3" in context.names:
            context.provided["actuator3"] = ProvidedValue().withValue(sponge.getVariable("actuator3", None))
        if "actuator5" in context.names:
            context.provided["actuator5"] = ProvidedValue().withValue(sponge.getVariable("actuator5", None)).withValueSet([
                "X", "Y", "Z", context.current["actuator1"]])

def onStartup():
    sponge.logger.debug("The provided value of actuator1 is: {}", sponge.provideActionArgs("SetActuator", ["actuator1"])["actuator1"].getValue())
----

.Console output
----
The provided value of actuator1 is: A
----

A provided argument can be `readOnly`. In that case its value in the `onCall` method should be ignored. A read only argument type has to be nullable.

A provided argument can _depend_ on other arguments but only those that are specified earlier. In the example argument `actuator5` depends on `actuator1`. Its possible value set contains the value of `actuator1`.

Arguments configured as provided have to be calculated in the `onProvideArgs` callback method and set in the `provided` map. For each provided argument its value and possible value set can be produced as the instance of the `ArgValue` class. The optional `withValue` method sets the provided value. The optional `withAnnotatedValueSet` method sets the value set along with annotations (e.g. labels) where each element is an instance of the `AnnotatedValue` class. The optional `withValueSet` method sets the possible value set with no annotations.

The parameter `names` in the `onProvideArgs` is a set of argument names that are to be provided. The `current` parameter is a not null map of argument names and their current values passed from a client code. The current value means the value used in a client code, for example entered by a user into an UI before calling the action. This map is required to contain values of those arguments that the arguments specified in the `names` depend on.

== Implementing interfaces
Actions may implement additional Java interfaces. It could be used to provide custom behavior of actions.

.Action implementing a Java interface
[source,python]
----
from org.openksavi.sponge.integration.tests.core import TestActionVisibiliy

class EdvancedAction(Action, TestActionVisibiliy): # <1>
    def onCall(self, text):
        return text.upper()
    def isVisible(self, context):
        return context == "day"
----
<1> The Java interface `TestActionVisibiliy` declares only one method `boolean isVisible(Object context)`.

