= User Guide

== Abstract
{sponge} is a polyglot system that allows creating knowledge bases in several scripting languages.

For the purpose of clarity, examples in this chapter are written in Python (http://www.jython.org[Jython^]) as one of the supported scripting languages and in Java. All examples written in Python may have equivalent ones written in any of the other <<supported-script-languages,supported script languages>>.


include::includes/sponge-user-guide-architecture.adoc[leveloffset=+1]


== Main components

include::includes/sponge-user-guide-configuration.adoc[leveloffset=+2]

include::includes/sponge-user-guide-knowledge-bases.adoc[leveloffset=+2]


=== Events
Events are the basic element of processing in {sponge}. They have standard attributes such as id, name, time and priority, that are associated with each event instance.

The name of an event is also the type of this event, so all events than have the same name are of the same type. Event names should follow Java naming conventions for variable names.

These attributes could be read by invoking functions:

* `getId()` - the global unique identifier of the event (String).
* `getName()` - the name (type) of the event.
* `getPriority()` - the priority of the event.
* `getTime()` - the time of adding the event to the input queue (represented as `java.time.Instant`).

Attributes `id` and `time` are automatically set when adding an event to the input queue and there is no need of setting them manually. The field `name` defines a type of the event and during processing it will be processed by event processors registered for this name.

Apart from this, you could add any number of additional attributes to each event by invoking the `set(name, value)` method. Those attributes will be later available for example in event processors.

{sponge} supports only point-in-time events.

==== Event queues
Events that haven't been processed (i.e. listened to) by any event processor in the Main Processing Unit are sent to the Output Event Queue. Default behavior in such case is to forget such events.

==== Event priorities
A priority defines a level of the importance of an event. Events are added to and taken from queues with respect to their priorities. Priority is an integer number and the higher the number is, the higher is the priority of an event and the event will be processed before the others.

Each event is given a priority `0` by default. *For standard events the priority always equals to `0` and cannot be modified.* 

A priority may be assigned only to control events.

==== Typical event processing
In order to process an event there must be an event processor listening to events of that type (the types of events are recognized by their names). So this steps should be taken:

* Creating an event processor.
* Enabling the event processor automatically or manually (by invoking a proper `EPS.enable*()` method).
* Creating a new event instance and sending it to the system (e.g. `EPS.event("alarm").set("location", "Building 1").send()`.
* The event goes directly to the Input Queue or is scheduled to be inserted to the Input Queue later. Scheduling is performed by the Event Scheduler.
* From this queue the events are taken by the Filter Processing Unit. The list of filters defined for this event type is taken and then each of them is invoked. If all the filters accept the event, it will be put to the main queue in which it awaits to be processed by other event processors.
* Then the event is collected by the Main Processing Unit. The list of event processors listening to this type of events is selected and then each of them is given the event to process.
* After processing by the Main Processing Unit the event goes to the output queue if and only if it hasn't been processed (i.e. listened to) by any of event processors.

==== Event cloning
The event is cloned each time when the periodically generated events are sent to the input queue.

The standard implementation of events allows choosing the cloning policy `shallow` or `deep`. These policies differ in the way of cloning of events attributes. When using the first of them, the references to attributes are copied - each event processor works on the same attribute instances. The policy `deep` executes the procedure of deep cloning, so each next generated event will contain individual copies of the attributes.

==== Custom events
{sponge} allows to use custom event implementations, apart from the default implementation of `Event` type (i.e. `AttributeMapEvent` class). It requires implementation of `Event` interface.

==== Creating and sending events
*Creating an event means creating an instance of an event class. Sending an event means that the created event will be put into the Input Event Queue, to be processed by filters and then by triggers, rules and correlators.*

Event could be created and sent:

* using the EventDefinition fluent API (e.g. `EPS.event("helloEvent").set("say", "Hello World!").send()`),
* using traditional API (e.g. `EPS.send(EPS.makeEvent("helloEvent").set("say", "Hello World!"))`).

The EventDefinition fluent API is preferred for sending events.

Method `EPS.event` returns `EventDefinition`.

Methods of sending events allow to send events as:

* single instance – an event will be placed in the input queue only once,
* many instances periodically – new instances of an event will be placed in the input queue periodically, each of them with its own identification and time of placement in the input queue.

==== Methods used for sending events
`send()`:: Sends an event immediately.
`sendAfter(delay)`:: Sends an event after the specified time (given in milliseconds).
`sendAfter(delay, interval)`:: Periodically sends events after the specified time (given in milliseconds) every `interval` (given in milliseconds).
`sendAt(at)`:: Sends an event at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970).
`sendAt(at, interval)`:: Periodically sends events starting at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970) every `interval` (given in milliseconds).
`sendAt(crontabSpec)`:: Sends events at time stated by the Cron specification.

==== Control events
Control events are used by the engine internally. The names of control events have a prefix `$`. You shouldn't give to your event a name that starts with this character.

==== Examples of sending events
Sample sending of events from the level of a knowledge base:

[source,python]
----
EPS.event("e1").sendAfter(1000)
----
Sends the event named `"e1"` after `1` second from now.

[source,python]
----
EPS.event("e2").sendAfter(2000, 1000)
----
Sends the event named `"e2"` after `2` seconds from now. New events will be periodically generated and sent every second.

[source,python]
----
EPS.event("e2").set("color", "red").set("severity", 5).send()
----
Sends an event with attributes `"color"` and `"severity"` immediately.

[source,python]
----
EPS.event("alarm").sendAt("0-59 * * * * ?")
----
Sends an event at the time specified by a cron notation.

=== Processors
Processors are the basic objects that you define in {sponge} to implement your knowledge base behavior.

Types of processors:

* *Event processors* - processors that perform specified operations using events they listen to.
** *Filters* - event processors used for allowing only certain events to be later processed by other event processors.
** *Triggers* -  event processors that execute a specified code when an event happens.
** *Event set processors* - event processors that process sets of events.
*** *Rules* - event set processors that detect ordered sequences of events.
*** *Correlators* - event set processors that detect any set of events and could be also used for implementing any complex event processing that isn't provided by filters, triggers or rules.
* *Actions* - processors that provide functionality similar to functions. They don't listen to events.

include::includes/sponge-user-guide-event-processors.adoc[leveloffset=+2]


=== Actions
Actions provide functionality that is to be used in many knowledge bases that are written in different languages.

Every action should implement the abstract `run` method:

[source,java]
----
Object run(Object... args);
----

==== Important methods
`configure()`:: A configuration callback method.
`init()`:: An initialization callback method that is invoked while creating a new action instance after `configure`.
`run(args)`:: A callback method invoked when the action is called, e.g.: `EPS.callAction()`.  This method is mandatory.

==== Example in a script language
The code presented below defines an action named `EchoAction` that simply returns all arguments.

.Action example
[source,python]
----
class EchoAction(Action): # <1>
    def configure(self): # <2>
        self.displayName = "Echo Action" # <3>
    def run(self, args): # <4>
        return args

def onStartup():
    result = EPS.callAction("EchoAction", 1, "test") # <5>
    logger.debug("Action returned: {}", result)
----
<1> The definition of the action `EchoAction`. The action is represented by a class of the same name.
<2> The action configuration callback method.
<3> Sets `displayName`.
<4> The action `run` callback method.
<5> Calls the action named `"EchoAction"` passing two arguments. The result is saved in a local variable.

.Console output
----
Action returned: [1, test]
----

==== Example in Java
The code presented below defines a Java-based action named `JavaEchoAction` that simply returns all arguments.

.Java action example
[source,java]
----
public class JavaEchoAction extends JavaAction { // <1>

    @Override
    public Object run(Object... args) { // <2>
        return args;
    }
}
----
<1> The definition of the action `JavaEchoAction`. The action is represented by a Java class of the same name.
<2> The action `run` callback method.

.Java action manual registration in the Python knowledge base
[source,python]
----
EPS.enableJava(JavaEchoAction)
----


=== Plugins
Plugins are used for expanding {sponge} with new functionalities and use them in knowledge bases. They provide access to and from external systems.

Every plugin has to implement `IPlugin` interface. There is also an abstract class `AbstractPlugin` containing implementations of basic methods. `AbstractPlugin` provides empty implementations of methods responsible for configuration (`configure()`), as well as callback methods being invoked during starting up (`onStartup()`), shutting down (`onShutdown()`), before and after reloading the plugin (`onBeforeReload()`, `onAfterReload()`). If the created plugin requires additional configuration parameters (e.g. in the XML configuration file) or performing some operations then the proper methods should be overridden.

Plugins could be written in Java or in a supported scripting language as a part of a scripting knowledge base. However plugins written in a scripting language must be used only in the same scripting knowledge base they were defined in. That is because there are limitations of scripting languages interoperation. Only plugins written in Java could be used in any scripting knowledge base.

TIP: When defining plugins, it should be taken into consideration that {sponge} is multi-threaded so references to a plugin should be thread-safe.

==== Example in Java

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="http://www.openksavi.org/sponge" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.openksavi.org/sponge http://www.openksavi.org/sponge/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase" type="python">
            <file>examples/script/py/plugins_java.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="echoPlugin" description="A simple plugin used as an example" 
                class="org.openksavi.sponge.examples.EchoPlugin">
            <echo>Echo test!</echo>
            <count>2</count>
        </plugin>
    </plugins>
</sponge>
----

This plugin definition section contains:

* The unique name of the plugin. This name may be used in knowledge bases as a variable of the same name that is a reference to this plugin instance.
* The description of the plugin.
* The class name of the plugin. It could be a Java class name or a scripting language class name. If the plugin is defined in a scripting knowledge base than you must specify that knowledge base name as an XML tag `<knowledgeBaseName>`.
* Custom configuration for a plugin. That section could be any XML that is understood by this plugin.

The above configuration defines a plugin implemented by `org.openksavi.sponge.examples.EchoPlugin` class. This plugin may be used in the knowledge base as a global variable named `echoPlugin` (according to the `name` attribute). There are additional configuration parameters defined for this plugin. These parameters could be read in the `configure()` method of the plugin class, called before starting the plugin.

.Java plugin example
[source,java]
----
public class EchoPlugin extends JavaPlugin { // <1>

    private static final Logger logger = LoggerFactory.getLogger(EchoPlugin.class);

    private String echo = "noecho";

    private int count = 1;

    public EchoPlugin() {
    }

    @Override
    public void configure(IConfiguration configuration) {  // <2>
        echo = configuration.getString("echo", echo);
        count = configuration.getInt("count", count);
    }

    @Override
    public void init() {  // <3>
        logger.debug("Initializing {}", getName());
    }

    @Override
    public void onStartup() { // <4>
        logger.debug("Starting up {}", getName());
    }

    public String getEcho() {
        return echo;
    }

    public void setEcho(String echo) {
        this.echo = echo;
    }

    public int getCount() {
        return count;
    }

    public String getEchoConfig() {
        return echo + " x " + count;
    }

    public void sendEchoEvent() {
        getEps().event("echoEvent").set("echo", getEcho()).send();
    }
}
----
<1> The definition of the plugin class.
<2> The plugin configuration callback method.
<3> The plugin initialization callback method.
<4> The plugin startup callback method.

==== Using plugins

.Using plugin in a script knowledge base
[source,python]
----
class PluginTrigger(Trigger):
    def configure(self):
        self.event = "e1"
    def run(self, event):
        self.logger.debug("Echo from the plugin: {}", echoPlugin.echo) # <1>
----
<1> Obtaining `echo` bean property from the plugin that is an instance of the class `EchoPlugin`.

The `name` of the plugin is also its identification in knowledge bases. The access to the plugin could be achieved in two ways:

* directly using the name `echoPlugin` as any other scripting language variable (this is the preferred way),
* `plugin = EPS.getPlugin("echoPlugin")`.

Because `echoPlugin` implements the method `getEcho()`, you may invoke it in two ways:

* `EPS.getPlugin("echoPlugin").echo`
* `echoPlugin.echo`

==== Example in a script language

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="http://www.openksavi.org/sponge" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.openksavi.org/sponge http://www.openksavi.org/sponge/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase" type="python">
            <file>examples/script/py/plugins_script.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="scriptPlugin" class="ScriptPlugin" knowledgeBaseName="sampleKnowledgeBase">
            <storedValue>Value A</storedValue>
        </plugin>
    </plugins>
</sponge>
----

.Scripting language plugin example
[source,python]
----
class ScriptPlugin(Plugin):
    def configure(self, configuration):
        self.storedValue = configuration.getString("storedValue", "default")
    def init(self):
        self.logger.debug("Initializing {}", self.name)
    def onStartup(self):
        self.logger.debug("Starting up {}", self.name)
    def getStoredValue(self):
        return self.storedValue
    def setStoredValue(self, value):
        self.storedValue = value
----

==== Plugin life cycle
{sponge} loads plugins when starting the system according to the steps:

. Create the plugin class instance. The class must have a no-parameter constructor.
. Configure the plugin by invoking the method `configure()`.
. Initialize the plugin by invoking the method `init()`.
. Invoke the callback method `onStartup()` when starting the engine.
. After starting all plugins the methods `onStartup()` defined in all knowledge bases are invoked.
. In case of reloading the knowledge base, the method `onBeforeReload()` of each plugin is invoked before the method `onBeforeReload()` of  knowledge bases. Invoking of the methods `onAfterReload()` goes in reverse (first the methods `onAfterReload()` of all knowledge bases and then the methods defined in plugins).
. Before {sponge} shuts down, methods `onShutdown()` of all knowledge bases are invoked and then a method `onShutdown()` is invoked for each plugin.


== Exception handling
{sponge} introduces its own exception defined as a Java class `SpongeException`. Exception handling in custom Java components (for example plugins) should follow standard Java conventions. Exception handling in scripting knowledge bases should follow standard conventions for corresponding scripting language (e.g. Python).

== Embedding {sponge} in custom applications
{sponge} may be embedded in a custom Java application using <<engine-builder-api,Engine Builder API>>.

include::includes/sponge-user-guide-integration.adoc[leveloffset=+1]

== Best practices
When developing an application using {sponge} you have to be aware of the fact that knowledge bases could be created in two categories of programming languages:

* Java,
* supported scripting languages (e.g. Python, Ruby, Groovy, JavaScript).

Each of these two categories has its pros and cons which makes it better for a certain use. For example scripting languages work well when flexible modification of source code is required.

All libraries written in Java or supported scripting languages may be used. Make sure that they are compatible with the implementations of these languages.

The following chapters describe best practices for some use cases.

=== Events
{sponge} is used for developing applications based on event processing. That is why you should start with defining event types. Events should contain enough information (in the form of attributes) so that event processors could provide demanded logic. Moreover, if necessary, you should consider using event chaining, i.e. sending events of a more abstract level based on correlations of low level events.

=== Plugins
If there is a need for creating an interface to an external system, the best way is to use existing or create a new plugin. Once written plugin could be used in other {sponge} based applications.

*In most cases a CamelPlugin, by providing access to all Camel components, should be sufficient when integrating with various systems.*

If there is a need for creating a custom plugin, in most use cases we suggest creating it in Java rather than in a scripting language, because of the benefits of a Java type-safety and to separate adaptability of scripting languages from robustness of Java.

=== Processors
When defining a processor that is not a singleton, its class implementation should provide lightweight creating of new instances.

=== Filters
Filters are especially important when an application cooperates with an external system. If such system sends events, it is a good practice to check if an event contains all expected information and if event attribute values are valid. This type of selection could be done in filters. Filters may also prevent from idly processing events that should be ignored by the application logic at early phase as they can have an impact on the whole performance.

=== Triggers
Triggers should be implemented in a way to support concurrent processing of many events by different threads. You should avoid class level (static) variables and restrict, if possible, to data transfered in events.

=== Rules
Rules should be used when triggers functionality is not sufficient for the problem you try to solve.

=== Correlators
Correlators should be used when filters, triggers and rules functionality is not sufficient for the problem you try to solve.

=== Actions
Actions should be created only when there is a need to provide some functionality that is to be used in many knowledge bases that are written in different scripting languages and only when you don't want to write it in Java.


== Scripting languages

[[supported-script-languages]]
=== Supported languages
.Supported knowledge base scripting languages
[width=50%]
|===
|Language |Implementation

|Python
|Jython

|Ruby
|JRuby

|Groovy
|Groovy

|JavaScript
|Nashorn
|===

=== Python

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jython</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

The dependency for Jython used in {sponge} is https://github.com/scijava/jython-shaded[Jython shaded^].

=== Ruby

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jruby</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== Groovy

==== Limitations
In Groovy you cannot define a class or a function twice in the same file. If you want to reload an event processor or an action, you have to put it in a separate file and use `EPS.reloadClass()` method. That separate file could be modified and reloaded.

.Example
[source,groovy]
----
void onLoad() {
    EPS.reloadClass(TriggerA)
    EPS.enable(TriggerA)

    EPS.reloadClass(FunctionAAction)
    EPS.enable(FunctionAAction)
    EPS.callAction("FunctionAAction")
}
----

For every knowledge base file there is a new Groovy `Script` instance created. For example when reloading, a new Groovy `Script` instance is created for each knowledge base file and they are placed in a list (in a reverse order) to be used by the {sponge} Groovy interpreter internally.

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-groovy</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== JavaScript
JavaScript interpreter supports https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/shell.html[shell scripting extensions in Nashorn^] to provide simpler shell integration.

==== Limitations
There is a limitation for using custom class attributes and methods in event processors written in JavaScript implementation Nashorn. In that case you should set a class field `target` in the `init()` method as in the following example. All class fields and methods that are new (i.e. not inherited from the base classes) *must be defined in `target`*.

.JavaScript target
[source,javascript]
----
var HeartbeatFilter = Java.extend(Filter, {
    configure: function(self) {
        self.event = "heartbeat";
    },
    init: function(self) {
        self.target = new function() { // <1>
            this.heartbeatCounter = 0;
        }
    },
    accepts: function(self, event) {
        self.target.heartbeatCounter++; // <2>
        if (self.target.heartbeatCounter > 2) {
            EPS.removeEvent(hearbeatEventEntry);
            return false;
        } else {
            return true;
        }
    }
});
----
<1> Setting `target` that defines an attribute `heartbeatCounter`.
<2> Using `target` for accessing attribute `heartbeatCounter`.

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-nashorn</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== Logging
{sponge} uses https://www.slf4j.org[SLF4J^] facade for logging.

Examples and standalone version use https://logback.qos.ch[Logback^] as a logging implementation.

== Examples

=== Complete example projects of embedding {sponge}
The complete projects could be used as a point of reference to embed {sponge} in your Java application. They are placed in `sponge-examples-projects`.

==== News project
This project shows how to process news as events. It is placed in `sponge-examples-project-news` (see {sourcesUrl}/sponge-examples-projects/sponge-examples-project-news[sources^]).

Event flow:

* News are manually generated and sent as {sponge} events named `news` in `onStartup` function of the knowledge base named `newsGenerator`. Each event has custom attributes: `source` and `title`.
* Every event named `news` is filtered to discard news that have empty or short (according to `newsFilterWordThreshold` configuration property) titles. This is done by `NewsFilter` filter.
* Events named `news` are logged by `LogNewsTrigger` trigger.
* When there are no new `news` events (that passed filters) for a specified time, then `alarm` event is sent. This is done by `NoNewNewsAlarmRule` rule.
* `LatestNewsCorrelator` correlator listens to `news` events and stores the latest news in `storagePlugin` plugin in a Python `deque`. The number of latest news is configured as `latestNewsMaxSize` property.
* When `alarm` event happens, this fact is logged by `AlarmTrigger` trigger using `echoPlugin` plugin and `EmphasizeAction` action.


.Main class - NewsExampleMain
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-news/src/main/java/org/openksavi/sponge/examples/project/news/NewsExampleMain.java[lines=17..-1]
----

.{sponge} XML configuration file - config.xml
[source,xml]
----
include::{completeExamplesProject}/sponge-examples-project-news/config/config.xml[]
----

.Python-based knowledge base 'main' file - main_event_processors.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_event_processors.py[lines=5..-1]
----

.Python-based knowledge base 'main' file - main_functions.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_functions.py[lines=5..-1]
----

.Python-based knowledge base 'main' file - main_plugins.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_plugins.py[lines=5..-1]
----

.JavaScript-based knowledge base 'actions' file - actions.js
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/actions.js[actions.js]
----

.Python-based knowledge base that generates sample news - news_generator.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/news_generator.py[lines=5..-1]
----

.Java-based plugin class - MultiEchoPlugin
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-news/src/main/java/org/openksavi/sponge/examples/project/news/MultiEchoPlugin.java[lines=17..-1]
----

==== Camel RSS News project
This example is an enhancement over the News project example. It is placed in `sponge-examples-project-camel-rss-news` (see {sourcesUrl}/sponge-examples-projects/sponge-examples-project-camel-rss-news[sources^]).

The main change here is that news are acquired as RSS feeds from news services: BBC and CNN. Reading of RSS feeds and transformation to {sponge} events is performed in a Camel route. {sponge} acts as a producer in this Camel route. This example shows {sponge} as a consumer in other Camel routes as well.

This example also presents integration with Spring framework. A service provided as a Spring bean is accessed from the script knowledge base.

Notice that knowledge bases `main` and `actions` that existed in the News project example are not changed. This is because the main processing is independent of the input and output interfaces, protocols or data structures. Internal events (in this case `news` events) are normalized.

Event flow:

* RSS feeds are read from external sources, transformed to {sponge} events and sent to the {sponge} engine. This is done in Camel routes.
* Because of `main` knowledge base is the same as in the previous example, so are the event flow parts here.
* After time configured as a property `durationOfReadingRss` Camel routes that read RSS feeds from external sources are stopped. It simulates lack of new news. This is done in `simulator` knowledge base.
* When `alarm` event happens, not only `AlarmTrigger` (as described in the previous example) handles that event, but here also `ForwardAlarmTrigger` trigger, defined in `consumer` knowledge base. It sends the alarm message to:
** all Camel endpoints that use the Sponge engine as a consumer in their routes,
** to a specific endpoint given as URI.

.Main class - CamelRssNewsExampleMain
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/src/main/java/org/openksavi/sponge/examples/project/camelrssnews/CamelRssNewsExampleMain.java[lines=17..-1]
----

.Spring Java configuration - SpringConfiguration
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/src/main/java/org/openksavi/sponge/examples/project/camelrssnews/SpringConfiguration.java[lines=17..-1]
----

.{sponge} XML configuration file - config.xml
[source,xml]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/config/config.xml[]
----

.Python-based extended configuration - config.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/kb/config.py[lines=5..-1]
----

.Python-based knowledge base that sends messages to Camel as a consumer - consumer.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/kb/consumer.py[lines=5..-1]
----


=== Features examples
The features examples shows how to use certain functionalities. See the sources in {sourcesUrl}/sponge-jython/examples[Python examples^], {sourcesUrl}/sponge-jruby/examples[Ruby examples^], {sourcesUrl}/sponge-groovy/examples[Groovy examples^] and {sourcesUrl}/sponge-nashorn/examples[JavaScript examples^].

CAUTION: Not all examples will work in the standalone application because some of them require additional setup.

Directory `examples/script` contains examples implemented in all supported script languages (i.e. example named `rules` is placed respectively in `rules.py`, `rules.rb`, `rules.groovy` and `rules.js`). Each of these examples is also a test case with assertions invoked in the corresponding JUnit class (e.g. `RulesTest.java`).

.Examples of key features for all supported scripting languages
[cols="1,3"]
|===
|Name |Description

|`actions`
ifdef::useReferences[(link:sponge-examples.html#actions-py[py^], link:sponge-examples.html#actions-rb[rb^], link:sponge-examples.html#actions-groovy[groovy^], link:sponge-examples.html#actions-js[js^])]
|Shows how to use actions.

|`correlators`
ifdef::useReferences[(link:sponge-examples.html#correlators-py[py^], link:sponge-examples.html#correlators-rb[rb^], link:sponge-examples.html#correlators-groovy[groovy^], link:sponge-examples.html#correlators-js[js^])]
|Shows how to use correlators. The script defined correlator creates an event log - a list of all events that it listens to.

|`correlators_duration`
ifdef::useReferences[(link:sponge-examples.html#correlators_duration-py[py^], link:sponge-examples.html#correlators_duration-rb[rb^], link:sponge-examples.html#correlators_duration-groovy[groovy^], link:sponge-examples.html#correlators_duration-js[js^])]
|Shows how to use correlators with duration. The script defined correlator creates an event log - a list of all events that it listens to.

|`events_clone_policy`
ifdef::useReferences[(link:sponge-examples.html#events_clone_policy-py[py^], link:sponge-examples.html#events_clone_policy-rb[rb^], link:sponge-examples.html#events_clone_policy-groovy[groovy^], link:sponge-examples.html#events_clone_policy-js[js^], link:sponge-examples.html#events_clone_policy-xml-py[XML configuration^])]
|Shows difference between event clone policies.

|`events_cron`
ifdef::useReferences[(link:sponge-examples.html#events_cron-py[py^], link:sponge-examples.html#events_cron-rb[rb^], link:sponge-examples.html#events_cron-groovy[groovy^], link:sponge-examples.html#events_cron-js[js^])]
|Shows sending events using Cron.

|`events_removing`
ifdef::useReferences[(link:sponge-examples.html#events_removing-py[py^], link:sponge-examples.html#events_removing-rb[rb^], link:sponge-examples.html#events_removing-groovy[groovy^], link:sponge-examples.html#events_removing-js[js^])]
|Shows how to remove scheduled events.

|`filters_deduplication`
ifdef::useReferences[(link:sponge-examples.html#filters_deduplication-py[py^], link:sponge-examples.html#filters_deduplication-rb[rb^], link:sponge-examples.html#filters_deduplication-groovy[groovy^], link:sponge-examples.html#filters_deduplication-js[js^])]
|Shows how to use a deduplication filter to prevent from processing many events that carry the same information.

|`filters_java`
ifdef::useReferences[(link:sponge-examples.html#filters_java-py[py^], link:sponge-examples.html#filters_java-rb[rb^], link:sponge-examples.html#filters_java-groovy[groovy^], link:sponge-examples.html#filters_java-js[js^])]
|Shows how to use a Java-based filter.

|`filters`
ifdef::useReferences[(link:sponge-examples.html#filters-py[py^], link:sponge-examples.html#filters-rb[rb^], link:sponge-examples.html#filters-groovy[groovy^], link:sponge-examples.html#filters-js[js^])]
|Shows how to use script-based filters.

|`hello_world`
ifdef::useReferences[(link:sponge-examples.html#hello_world-py[py^], link:sponge-examples.html#hello_world-rb[rb^], link:sponge-examples.html#hello_world-groovy[groovy^], link:sponge-examples.html#hello_world-js[js^], link:sponge-examples.html#hello_world-xml-py[XML configuration^])]
|Hello world complete example.

|`knowledge_base_callbacks`
ifdef::useReferences[(link:sponge-examples.html#knowledge_base_callbacks-py[py^], link:sponge-examples.html#knowledge_base_callbacks-rb[rb^], link:sponge-examples.html#knowledge_base_callbacks-groovy[groovy^], link:sponge-examples.html#knowledge_base_callbacks-js[js^])]
|Shows how to use knowledge base callback functions: `onInit`, `onStartup`, `onShutdown`, `onBeforeReload` and `onAfterReload`.

|`knowledge_base_load`
ifdef::useReferences[(link:sponge-examples.html#knowledge_base_load-py[py^], link:sponge-examples.html#knowledge_base_load-rb[rb^], link:sponge-examples.html#knowledge_base_load-groovy[groovy^], link:sponge-examples.html#knowledge_base_load-js[js^])]
|Shows how to load an additional knowledge base file by using `EPS.interpreter.load()`.

|`knowledge_base_manager`
ifdef::useReferences[(link:sponge-examples.html#knowledge_base_manager-py[py^], link:sponge-examples.html#knowledge_base_manager-rb[rb^], link:sponge-examples.html#knowledge_base_manager-groovy[groovy^], link:sponge-examples.html#knowledge_base_manager-js[js^])]
|Shows knowledge base operations.

|`library`
ifdef::useReferences[(link:sponge-examples.html#library-py[py^], link:sponge-examples.html#library-rb[rb^], link:sponge-examples.html#library-groovy[groovy^], link:sponge-examples.html#library-js[js^], link:sponge-examples.html#library-xml-py[XML configuration^])]
|Shows how to use a scripting language specific library (e.g. `httplib` for Python) to check HTTPS host status.

|`plugins_java`
ifdef::useReferences[(link:sponge-examples.html#plugins_java-py[py^], link:sponge-examples.html#plugins_java-rb[rb^], link:sponge-examples.html#plugins_java-groovy[groovy^], link:sponge-examples.html#plugins_java-js[js^], link:sponge-examples.html#plugins_java-xml-py[XML configuration^])]
|Shows how to define and use a Java-based plugins.

|`plugins_script`
ifdef::useReferences[(link:sponge-examples.html#plugins_script-py[py^], link:sponge-examples.html#plugins_script-rb[rb^], link:sponge-examples.html#plugins_script-groovy[groovy^], link:sponge-examples.html#plugins_script-js[js^], link:sponge-examples.html#plugins_script-xml-py[XML configuration^])]
|Shows how to define and use a script-based plugins.

|`rules_events`
ifdef::useReferences[(link:sponge-examples.html#rules_events-py[py^], link:sponge-examples.html#rules_events-rb[rb^], link:sponge-examples.html#rules_events-groovy[groovy^], link:sponge-examples.html#rules_events-js[js^], link:sponge-examples.html#rules_events-xml-py[XML configuration^])]
|Shows how to define and use rules that have different event modes, durations etc.

|`rules_heartbeat`
ifdef::useReferences[(link:sponge-examples.html#rules_heartbeat-py[py^], link:sponge-examples.html#rules_heartbeat-rb[rb^], link:sponge-examples.html#rules_heartbeat-groovy[groovy^], link:sponge-examples.html#rules_heartbeat-js[js^])]
|Heartbeat complete example.

|`rules_none_mode_events_conditions`
ifdef::useReferences[(link:sponge-examples.html#rules_none_mode_events_conditions-py[py^], link:sponge-examples.html#rules_none_mode_events_conditions-rb[rb^], link:sponge-examples.html#rules_none_mode_events_conditions-groovy[groovy^], link:sponge-examples.html#rules_none_mode_events_conditions-js[js^])]
|Shows how to define and use rules that have `none` event mode and event conditions.

|`rules_none_mode_events`
ifdef::useReferences[(link:sponge-examples.html#rules_none_mode_events-py[py^], link:sponge-examples.html#rules_none_mode_events-rb[rb^], link:sponge-examples.html#rules_none_mode_events-groovy[groovy^], link:sponge-examples.html#rules_none_mode_events-js[js^])]
|Shows how to define and use rules that have `none` event mode.

|`rules`
ifdef::useReferences[(link:sponge-examples.html#rules-py[py^], link:sponge-examples.html#rules-rb[rb^], link:sponge-examples.html#rules-groovy[groovy^], link:sponge-examples.html#rules-js[js^])]
|Shows how to define and use rules. Event conditions are specified using lambda expressions as well as class methods.

|`triggers`
ifdef::useReferences[(link:sponge-examples.html#triggers-py[py^], link:sponge-examples.html#triggers-rb[rb^], link:sponge-examples.html#triggers-groovy[groovy^], link:sponge-examples.html#triggers-js[js^], link:sponge-examples.html#triggers-xml-py[XML configuration^])]
|Shows how to define and use triggers.
|===


.Examples for specific languages
[cols="1,3"]
|===
|Name |Description

|`fibonacci`
ifdef::useReferences[(link:sponge-examples.html#fibonacci-py[py^])]
|Shows how to send a chain of events, each carrying a Fibonacci number as an attribute.

|`engine_parameters`
ifdef::useReferences[(link:sponge-examples.html#engine_parameters-xml[xml^])]
|Shows how to set engine parameters in the XML configuration file.

|`spring`
ifdef::useReferences[(link:sponge-examples.html#spring-py[py^], link:sponge-examples.html#spring-java[java^])]
|Shows how to integrate with Spring framework.

|`camel_producer`
ifdef::useReferences[(link:sponge-examples.html#camel_producer-py[py^], link:sponge-examples.html#camel_producer-java[java^])]
|Shows how to handle messages coming from Apache Camel route by an {sponge} trigger.

|`camel_consumer`
ifdef::useReferences[(link:sponge-examples.html#camel_consumer-py[py^], link:sponge-examples.html#camel_consumer-java[java^])]
|Shows how to handle messages coming from {sponge} by an Apache Camel route.

|`camel_rss`
ifdef::useReferences[(link:sponge-examples.html#camel_rss-py[py^], link:sponge-examples.html#camel_rss-java[java^])]
|Shows how to integrate with Apache Camel to send and handle {sponge} events based on RSS feeds. This example uses a Spring configuration.

|`camel_producer_overridden_action`
ifdef::useReferences[(link:sponge-examples.html#camel_producer_overridden_action-py[py^], link:sponge-examples.html#camel_producer_overridden_action-java[java^])]
|Shows how to handle messages coming from Apache Camel route by an {sponge} trigger using an overridden Camel producer action.

|`camel_producer_custom_action`
ifdef::useReferences[(link:sponge-examples.html#camel_producer_custom_action-py[py^], link:sponge-examples.html#camel_producer_custom_action-java[java^])]
|Shows how to handle messages coming from Apache Camel route by an {sponge} trigger using a custom Camel producer action.

|`camel_multiple_consumer`
ifdef::useReferences[(link:sponge-examples.html#camel_multiple_consumer-py[py^], link:sponge-examples.html#camel_multiple_consumer-java[java^])]
|Shows sending Camel messages to many endpoints in a single {sponge} trigger.
|===

=== Standalone examples

.Examples for standalone {sponge}
[cols="1,3"]
|===
|Name |Description

|`standalone_news`
ifdef::useReferences[(link:{sourcesUrl}/sponge-examples/examples/standalone/news[sources^])]
|This example is based on complete example project of embedding {sponge} - News, but adjusted to a standalone version.

|`standalone_camel_rss_news`
ifdef::useReferences[(link:{sourcesUrl}/sponge-examples/examples/standalone/camel_rss_news[sources^])]
|This example is based on complete example project of embedding {sponge} - Camel RSS News, but adjusted to a standalone version.

|`camel_route_groovy`
ifdef::useReferences[(link:{sourcesUrl}/sponge-examples-projects/sponge-examples-project-standalone-camel-groovy[sources^])]
|Camel routes in Groovy Spring configuration.

|`camel_route_xml`
ifdef::useReferences[(link:{sourcesUrl}/sponge-examples-projects/sponge-examples-project-standalone-camel-xml[sources^])]
|Camel context and routes in XML Spring configuration.
|===

== Maven artifacts

.{sponge} Maven artifacts
[cols="1,1,2"]
|===
|GroupId |ArtifactId |Description

|`org.openksavi.sponge`
|`sponge-parent`
|Parent project.

|`org.openksavi.sponge`
|`sponge-bom`
|Bill Of Materials style pom.xml.

|`org.openksavi.sponge`
|`sponge-api`
|{sponge} API.

|`org.openksavi.sponge`
|`sponge-core`
|{sponge} core implementation. You may use this dependency if you don't need a scripting language support, for example when creating knowledge bases only in Java.

|`org.openksavi.sponge`
|`sponge-jython`
|Support for Python-based scripting knowledge bases using Jython.

|`org.openksavi.sponge`
|`sponge-jruby`
|Support for Ruby-based scripting knowledge bases using JRuby.

|`org.openksavi.sponge`
|`sponge-groovy`
|Support for Groovy-based scripting knowledge bases.

|`org.openksavi.sponge`
|`sponge-nashorn`
|Support for JavaScript-based scripting knowledge bases using Nashorn.

|`org.openksavi.sponge`
|`sponge-camel`
|Apache Camel integration.

|`org.openksavi.sponge`
|`sponge-spring`
|Spring framework integration.

|`org.openksavi.sponge`
|`sponge-standalone`
|Standalone distribution of {sponge}.

|`org.openksavi.sponge`
|`sponge-signal`
|Wrappers for Operating System signals.

|`org.openksavi.sponge`
|`sponge-examples`
|{sponge} examples.

|`org.openksavi.sponge`
|`sponge-examples-projects`
|{sponge} examples - complete projects with embedded {sponge}: `sponge-examples-project-news`, `sponge-examples-project-camel-rss-news`.

|`org.openksavi.sponge`
|`sponge-distribution`
|Contains documentation, release configuration etc.

|`org.openksavi.sponge`
|`sponge-test`
|{sponge} test support.


|`org.openksavi.sponge`
|`sponge-integration-tests`
|Internal integration tests.
|===


include::includes/sponge-user-guide-standalone.adoc[leveloffset=+1]


== Third party software
{sponge} uses third party software released under various open-source licenses.

.Key third party software
[cols="1,1,2"]
|===
|Package |License |Description

|https://commons.apache.org/proper/commons-configuration/[Apache Commons Configuration^]
|Apache 2.0
|Used for reading configuration files.

|http://www.jython.org[Jython^]
|http://www.jython.org/license.html[Jython license^]
|Supports writing scripting knowledge bases in Python.

|http://jruby.org[JRuby^]
|EPL 1.0, GPL 2 or LGPL 2.1
|Supports writing scripting knowledge bases in Ruby.

|http://www.groovy-lang.org[Groovy^]
|Apache 2.0
|Supports writing scripting knowledge bases in Groovy.

|https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/[Nashorn^]
|GPL with a linking exception
|Supports writing scripting knowledge bases in JavaScript.

|http://www.quartz-scheduler.org[Quartz^]
|Apache 2.0
|Used for scheduling events (e.g. provides cron functionality).

|http://camel.apache.org[Apache Camel^]
|Apache 2.0
|Used as an integration facade to external systems.

|http://projects.spring.io/spring-framework[Spring framework^]
|Apache 2.0
|Used for integration with Spring framework.

|https://github.com/google/guava[Guava^]
|Apache 2.0
|Used for services and as a utilities library.
|===

The complete list of these libraries may be found in the `THIRD-PARTY.txt` and `licenses.xml` files of the standalone distribution as well as in the source code (Maven dependencies).