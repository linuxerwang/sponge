= User Guide
:page-permalink: /user-guide/
:toc:

== Introduction
{sponge} is a polyglot system that allows creating knowledge bases in several scripting languages.

For the purpose of clarity, examples in this chapter are written in Python (http://www.jython.org[Jython]) as one of the supported scripting languages and in Java. All examples written in Python may have equivalent ones written in any of the other <<supported-script-languages,supported script languages>>.


include::includes/sponge-user-guide-architecture.adoc[leveloffset=+1]


include::includes/sponge-user-guide-configuration.adoc[leveloffset=+1]

== Engine

=== Starting up
To startup the engine you should invoke the `startup()` method. After startup, the engine runs in the background (i.e. using threads other than the current one) until you shutdown it.

.Example of starting up
[source,java]
----
Engine engine = DefaultEngine.builder().config("examples/script/py/hello_world.xml").build();
engine.startup();
----

=== Shutting down

When a {sponge} instance is no longer needed it should be shut down by invoking `shutdown()` or `requestShutdown()` method. It instructs the engine to do some clean up, stop all managed threads, free resources, etc. The `shutdown()` uses the current thread to stop the engine. The `requestShutdown()` uses a new thread to stop the engine, thus allowing to shutdown the engine from the within, e.g. form an event processor.

.Example of shutting down in Java
[source,java]
----
engine.shutdown();
----

.Example of shutting down in a script language
[source,python]
----
class A(Trigger):
    def configure(self):
        self.event = "e1"
    def run(self, event):
        EPS.engine.requestShutdown()
----

Shutting down doesn't guarantee that all events sent to the engine will be processed. However, all events that have already been read from the Input Event Queue (by the Filter Processing Unit) will be fully processed by the engine, if the processing doesn't exceed shutdown timeouts (specified by the `executorShutdownTimeout` configuration parameter). All newer events remaining in the Input Event Queue will not be processed at all.

include::includes/sponge-user-guide-knowledge-bases.adoc[leveloffset=+1]


== Events
Events are the basic element of processing in {sponge}. They have standard attributes such as id, name and time that are associated with each event instance.

The name of an event is also the type of this event, so all events than have the same name are of the same type. Event names should follow Java naming conventions for variable names.

These attributes could be read by invoking functions:

* `getId()` - the global unique identifier of the event (String).
* `getName()` - the name (type) of the event.
* `getTime()` - the time of adding the event to the input queue (represented as `java.time.Instant`).

Attributes `id` and `time` are automatically set when adding an event to the input queue and there is no need of setting them manually. The field `name` defines a type of the event and during processing it will be processed by event processors registered for this name.

Apart from this, you could add any number of additional attributes to each event by invoking the `set(name, value)` method. Those attributes will be later available for example in event processors.

{sponge} supports only point-in-time events.

=== Event queues
Events that have been ignored (i.e. events that haven't been listened to by any event processor) are sent to the Output Event Queue. The default behavior in such case is to forget such events. You may see these events in the logs by setting the `sponge.event.ignored` logger to `INFO`.

=== Event priorities
A priority may be assigned only to control events, that are used internally by the engine. For standard events the priority always equals to `0` and cannot be modified.

A priority defines a level of the importance of an event. Events are added to and taken from queues with respect to their priorities. Priority is a positive or negative integer and the higher the number is, the higher is the priority of an event and the event will be processed before the others.

=== Typical event processing
In order to process an event there must be an event processor listening to events of that type (the types of events are recognized by their names). So this steps should be taken:

* Creating an event processor.
* Enabling the event processor automatically or manually (by invoking a proper `EPS.enable*()` method).
* Creating a new event instance and sending it to the system (e.g. `EPS.event("alarm").set("location", "Building 1").send()`.
* The event goes directly to the Input Queue or is scheduled to be inserted to the Input Queue later. Scheduling is performed by the Event Scheduler.
* From this queue the events are taken by the Filter Processing Unit. The list of filters defined for this event type is taken and then each of them is invoked. If all the filters accept the event, it will be put to the main queue in which it awaits to be processed by other event processors.
* Then the event is collected by the Main Processing Unit. The list of event processors listening to this type of events is selected and then each of them is given the event to process.
* After processing by the Main Processing Unit the event goes to the output queue if and only if it hasn't been processed (i.e. listened to) by any of event processors.

=== Event cloning
The event is cloned each time when the periodically generated events are sent to the input queue.

The standard implementation of events allows choosing the cloning policy `shallow` or `deep`. These policies differ in the way of cloning of events attributes. When using the first of them, the references to attributes are copied - each event processor works on the same attribute instances. The policy `deep` executes the procedure of deep cloning, so each next generated event will contain individual copies of the attributes.

=== Custom events
{sponge} allows to use custom event implementations, apart from the default implementation of `Event` type (i.e. `AttributeMapEvent` class). It requires implementation of `Event` interface.

=== Creating and sending events
*Creating an event means creating an instance of an event class. Sending an event means that the created event will be put into the Input Event Queue, to be processed by filters and then by triggers, rules and correlators.*

Event could be created and sent:

* using the EventDefinition fluent API (e.g. `EPS.event("helloEvent").set("say", "Hello World!").send()`),
* using traditional API (e.g. `EPS.send(EPS.makeEvent("helloEvent").set("say", "Hello World!"))`).

The EventDefinition fluent API is preferred for sending events.

Method `EPS.event` returns `EventDefinition`.

Methods of sending events allow to send events as:

* single instance – an event will be placed in the input queue only once,
* many instances periodically – new instances of an event will be placed in the input queue periodically, each of them with its own identification and time of placement in the input queue.

=== Methods used for sending events
`send()`:: Sends an event immediately.
`sendAfter(delay)`:: Sends an event after the specified time (given in milliseconds).
`sendAfter(delay, interval)`:: Periodically sends events after the specified time (given in milliseconds) every `interval` (given in milliseconds).
`sendAt(at)`:: Sends an event at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970).
`sendAt(at, interval)`:: Periodically sends events starting at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970) every `interval` (given in milliseconds).
`sendAt(crontabSpec)`:: Sends events at time stated by the Cron specification.

=== Control events
Control events are used by the engine internally. The names of control events have a prefix `$`. You shouldn't give to your event a name that starts with this character.

=== Examples of sending events
Sample sending of events from the level of a knowledge base:

[source,python]
----
EPS.event("e1").sendAfter(1000)
----
Sends the event named `"e1"` after `1` second from now.

[source,python]
----
EPS.event("e2").sendAfter(2000, 1000)
----
Sends the event named `"e2"` after `2` seconds from now. New events will be periodically generated and sent every second.

[source,python]
----
EPS.event("e2").set("color", "red").set("severity", 5).send()
----
Sends an event with attributes `"color"` and `"severity"` immediately.

[source,python]
----
EPS.event("alarm").sendAt("0-59 * * * * ?")
----
Sends an event at the time specified by a cron notation.

== Processors
Processors are the basic objects that you define in {sponge} to implement your knowledge base behavior.

Types of processors:

* *Event processors* - processors that perform specified operations using events they listen to.
** *Filters* - event processors used for allowing only certain events to be later processed by other event processors.
** *Triggers* -  event processors that execute a specified code when an event happens.
** *Event set processors* - event processors that process sets of events.
*** *Rules* - event set processors that detect ordered sequences of events.
*** *Correlators* - event set processors that detect any set of events and could be also used for implementing any complex event processing that isn't provided by filters, triggers or rules.
* *Actions* - processors that provide functionality similar to functions. They don't listen to events.

=== Enabling processors
The operation of registering a processor in the engine is called enabling. Registered processors are available to the engine to perform specific tasks. For example, after enabling an event processor starts listening to the events it is interested in.

Processors could be enabled:

* by auto-enable (this is the default setting for script-based processors),
* manually.

==== Auto-enable
{sponge} automatically enables all processors (i.e. actions, filters, triggers, rules and correlators) defined in a knowledge base. This is done just before invoking `onLoad` callback function in the knowledge base.

CAUTION: Processors defined in script knowledge bases have to extend the correct base classes, otherwise they wouldn't be enabled automatically.

The auto-enable feature scans only for processors defined in the scripting knowledge base. Enabling Java-based processors have to be done manually.

You may turn off auto-enable by setting the `autoEnable` engine configuration parameter to `false` (for example in the Sponge XML configuration file). In that case you have to enable processors manually.

==== Manual enabling
In most cases enabling processors manually should be done in `onLoad` callback function.

To manually enable any script-based processors in the script knowledge base you may use `EPS.enable()` to enable one processor and `EPS.enableAll()` to enable many processors.

.Enabling script-based processor example
[source,python]
----
def onLoad:
    EPS.enable(TriggerA)
----

.Enabling script-based processors example
[source,python]
----
def onLoad:
    EPS.enableAll(Trigger1, Trigger3)
----

To manually enable any Java-based processors in the script knowledge base you may use `EPS.enableJava()` and `EPS.enableJavaAll()`.

.Enabling Java-based processor example
[source,python]
----
def onLoad():
    EPS.enableJava(SameSourceJavaRule)
----

=== Disabling processors
Processors could be disabled only manually. To disable any script-based processors in the script knowledge base you may use `EPS.disable()` to disable one processor and `EPS.disableAll()` to disable many processors.

.Disabling script-based processor example
[source,python]
----
def onLoad:
    EPS.disable(EchoAction)
----

To disable any Java-based processors in the script knowledge base you may use `EPS.disableJava()` and `EPS.disableJavaAll()`.

.Disabling Java-based processor example
[source,python]
----
def onLoad():
    EPS.disableJava(SameSourceJavaRule)
----

=== Properties and methods

[[processor-methods]]
.Processor properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|*`configure()`*
|A configuration callback method that is invoked when a processor is being enabled. This method is mandatory.

|`init()`
|An initialization callback method that is invoked after `configure()` each time a new working instance of the processor is created.

|`name`
|A property that is the name of the processor. This is a shortcut for `getName()`/`setName(text)` methods. Because of names of processors are created automatically, the setter shouldn't be used in a client code.

|`displayName`
|A property that is the display name of the processor. This is a shortcut for `getDisplayName()`/`setDisplayName(text)` methods. A display name is not used internally but may be useful for a client code.

|`logger`
|A read-only property that provides a processor logger. This is a shortcut for `getLogger()` method. A processor logger name has the following format: `sponge.kb.<language>.<knowledgeBaseName>.<processorName>`. Example logger names: `sponge.kb.python.kb1.EchoAction` for a python-based processor or `sponge.kb.python.kb1.org.openksavi.sponge.examples.PowerEchoAction` for a Java-based processor enabled in a Python-based knowledge base.

|`adapter`
|A read-only property that provides a processor adapter. This is a shortcut for `getAdapter()` method. A processor adapter is an internal object, associated with the processor, that is used by the engine. There should be no need to use this property in the client code.
|===

include::includes/sponge-user-guide-event-processors.adoc[leveloffset=+1]


== Actions
Actions provide functionality that is to be used in many knowledge bases that are written in different languages.

Every action should implement the abstract `run` method:

[source,java]
----
Object run(Object... args);
----

=== Properties and methods
In addition to the inherited <<processor-methods,processor properties and methods>>, actions provide the following ones.

.Action properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`Object run(args)`
|A callback method invoked when the action is called, e.g.: `EPS.callAction()`. The argument in an array of `Object`s and the result in an `Object`. This method is mandatory.
|===

The `configure` method in actions is not mandatory.

=== Example in a script language
The code presented below defines an action named `EchoAction` that simply returns all arguments.

.Action example
[source,python]
----
class EchoAction(Action): # <1>
    def configure(self): # <2>
        self.displayName = "Echo Action" # <3>
    def run(self, args): # <4>
        return args

def onStartup():
    result = EPS.callAction("EchoAction", 1, "test") # <5>
    logger.debug("Action returned: {}", result)
----
<1> The definition of the action `EchoAction`. The action is represented by a class of the same name.
<2> The action configuration callback method.
<3> Sets `displayName`.
<4> The action `run` callback method.
<5> Calls the action named `"EchoAction"` passing two arguments. The result is saved in a local variable.

.Console output
----
Action returned: [1, test]
----

=== Example in Java
The code presented below defines a Java-based action named `JavaEchoAction` that simply returns all arguments.

.Java action example
[source,java]
----
public class JavaEchoAction extends JavaAction { // <1>

    @Override
    public Object run(Object... args) { // <2>
        return args;
    }
}
----
<1> The definition of the action `JavaEchoAction`. The action is represented by a Java class of the same name.
<2> The action `run` callback method.

.Java action manual registration in the Python knowledge base
[source,python]
----
EPS.enableJava(JavaEchoAction)
----


== Plugins
Plugins are used for expanding {sponge} with new functionalities and use them in knowledge bases. They provide access to and from external systems.

Every plugin has to implement `Plugin` interface. Java-based plugins should extend `JavaPlugin` class that extends `BasePlugin`. Script-based plugins should extend a class specific to the scripting language that in turn extends `BasePlugin`. Hopefully for all scripting languages there an alias to such class named simply `Plugin`.

Each plugin is also an engine module and that means that in inherits from `BaseEngineModule` class.

`BasePlugin` provides empty implementations of methods responsible for configuration (`configure()`), as well as callback methods being invoked during starting up (`onStartup()`), shutting down (`onShutdown()`), before and after reloading the plugin (`onBeforeReload()`, `onAfterReload()`). If the created plugin requires own configuration parameters (e.g. in the XML configuration file) the `configure()` method should be implemented.

Plugins could be written in Java or in a supported scripting language as a part of a scripting knowledge base. However plugins written in a scripting language must be used only in the same scripting knowledge base they were defined in. That is because there are limitations of scripting languages interoperation. Only plugins written in Java could be used in any scripting knowledge base.

TIP: When defining plugins, it should be taken into consideration that {sponge} is multi-threaded so references to a plugin should be thread-safe.

=== Properties and methods

.Plugin properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`configure(Configuration configuration)`
|A configuration callback method that is invoked after a plugin has been loaded. This method allows reading an XML configuration for the plugin.

|`init()`
|An initialization callback method that is invoked after a configuration of a plugin.

|`onStartup()`
|On startup callback method, called once after the startup of the engine.

|`onShutdown()`
|On shutdown callback method, called once before the shutdown of the engine.

|`onBeforeReload()`
|A callback method called before every reloading of the knowledge base.

|`onAfterReload()`
|A callback method called after every reloading of the knowledge base.

|`name`
|A property that is the name of the plugin. This is a shortcut for `getName()`/`setName(text)` methods. Because of names of plugins are created automatically, the setter shouldn't be used in a client code.

|`logger`
|A read-only property that provides a plugin logger. This is a shortcut for `getLogger()` method. A plugin logger name has the following format: `sponge.kb.plugin.<pluginName>`. Example logger name: `sponge.kb.plugin.scriptPlugin`.
|===


=== Example in Java

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="http://www.openksavi.org/sponge" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.openksavi.org/sponge http://www.openksavi.org/sponge/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase" type="python">
            <file>examples/script/py/plugins_java.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="echoPlugin" class="org.openksavi.sponge.examples.EchoPlugin">
            <configuration>
                <echo>Echo test!</echo>
                <count>2</count>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

This plugin definition section contains:

* The unique name of the plugin. This name may be used in knowledge bases as a variable of the same name that is a reference to this plugin instance.
* The class name of the plugin. It could be a Java class name or a scripting language class name. If the plugin is defined in a scripting knowledge base than you must specify that knowledge base name as an XML tag `<knowledgeBaseName>`.
* Custom configuration for a plugin. That section could be any XML that is understood by this plugin.

The above configuration defines a plugin implemented by `org.openksavi.sponge.examples.EchoPlugin` class. This plugin may be used in the knowledge base as a global variable named `echoPlugin` (according to the `name` attribute). There are additional configuration parameters defined for this plugin. These parameters could be read in the `configure()` method of the plugin class, called before starting the plugin.

.Java plugin example
[source,java]
----
public class EchoPlugin extends JavaPlugin { // <1>

    private static final Logger logger = LoggerFactory.getLogger(EchoPlugin.class);

    private String echo = "noecho";

    private int count = 1;

    public EchoPlugin() {
    }

    @Override
    public void configure(IConfiguration configuration) {  // <2>
        echo = configuration.getString("echo", echo);
        count = configuration.getInteger("count", count);
    }

    @Override
    public void init() {  // <3>
        logger.debug("Initializing {}", getName());
    }

    @Override
    public void onStartup() { // <4>
        logger.debug("Starting up {}", getName());
    }

    public String getEcho() {
        return echo;
    }

    public void setEcho(String echo) {
        this.echo = echo;
    }

    public int getCount() {
        return count;
    }

    public String getEchoConfig() {
        return echo + " x " + count;
    }

    public void sendEchoEvent() {
        getEps().event("echoEvent").set("echo", getEcho()).send();
    }
}
----
<1> The definition of the plugin class.
<2> The plugin configuration callback method.
<3> The plugin initialization callback method.
<4> The plugin startup callback method.

=== Using plugins

.Using plugin in a script knowledge base
[source,python]
----
class PluginTrigger(Trigger):
    def configure(self):
        self.event = "e1"
    def run(self, event):
        self.logger.debug("Echo from the plugin: {}", echoPlugin.echo) # <1>
----
<1> Obtaining `echo` bean property from the plugin that is an instance of the class `EchoPlugin`.

The `name` of the plugin is also its identification in knowledge bases. The access to the plugin could be achieved in two ways:

* directly using the name `echoPlugin` as any other scripting language variable (this is the preferred way),
* `plugin = EPS.getPlugin("echoPlugin")`.

Because `echoPlugin` implements the method `getEcho()`, you may invoke it in two ways:

* `EPS.getPlugin("echoPlugin").echo`
* `echoPlugin.echo`

=== Example in a script language

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="http://www.openksavi.org/sponge" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.openksavi.org/sponge http://www.openksavi.org/sponge/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase" type="python">
            <file>examples/script/py/plugins_script.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="scriptPlugin" class="ScriptPlugin" knowledgeBaseName="sampleKnowledgeBase">
            <configuration>
                <storedValue>Value A</storedValue>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

.Scripting language plugin example
[source,python]
----
class ScriptPlugin(Plugin):
    def configure(self, configuration):
        self.storedValue = configuration.getString("storedValue", "default")
    def init(self):
        self.logger.debug("Initializing {}", self.name)
    def onStartup(self):
        self.logger.debug("Starting up {}", self.name)
    def getStoredValue(self):
        return self.storedValue
    def setStoredValue(self, value):
        self.storedValue = value
----

=== Plugin life cycle
{sponge} loads plugins when starting the system according to the steps:

. Create the plugin class instance. The class must have a no-parameter constructor.
. Configure the plugin by invoking the method `configure()`.
. Initialize the plugin by invoking the method `init()`.
. Invoke the callback method `onStartup()` when starting the engine.
. After starting all plugins the methods `onStartup()` defined in all knowledge bases are invoked.
. In case of reloading the knowledge base, the method `onBeforeReload()` of each plugin is invoked before the method `onBeforeReload()` of  knowledge bases. Invoking of the methods `onAfterReload()` goes in reverse (first the methods `onAfterReload()` of all knowledge bases and then the methods defined in plugins).
. Before {sponge} shuts down, methods `onShutdown()` of all knowledge bases are invoked and then a method `onShutdown()` is invoked for each plugin.


== Exception handling
{sponge} introduces its own exception defined as a Java class `SpongeException`. Exception handling in custom Java components (for example plugins) should follow standard Java conventions. Exception handling in scripting knowledge bases should follow standard conventions for corresponding scripting language (e.g. Python).

== Embedding {sponge} in custom applications
{sponge} may be embedded in a custom Java application using <<engine-builder-api,Engine Builder API>>.

include::includes/sponge-user-guide-integration.adoc[leveloffset=+1]

== Best practices
When developing an application using {sponge} you have to be aware of the fact that knowledge bases could be created in two categories of programming languages:

* Java,
* supported scripting languages (e.g. Python, Ruby, Groovy, JavaScript).

Each of these two categories has its pros and cons which makes it better for a certain use. For example scripting languages work well when flexible modification of source code is required.

All libraries written in Java or supported scripting languages may be used. Make sure that they are compatible with the implementations of these languages.

The following chapters describe best practices for some use cases.

=== Events
{sponge} is used for developing applications based on event processing. That is why you should start with defining event types. Events should contain enough information (in the form of attributes) so that event processors could provide demanded logic. Moreover, if necessary, you should consider using event chaining, i.e. sending events of a more abstract level based on correlations of low level events.

=== Plugins
If there is a need for creating an interface to an external system, the best way is to use existing or create a new plugin. Once written plugin could be used in other {sponge} based applications.

*In most cases a CamelPlugin, by providing access to all Camel components, should be sufficient when integrating with various systems.*

If there is a need for creating a custom plugin, in most use cases we suggest creating it in Java rather than in a scripting language, because of the benefits of a Java type-safety and to separate adaptability of scripting languages from robustness of Java.

=== Processors
When defining a processor that is not a singleton, its class implementation should provide lightweight creating of new instances.

=== Filters
Filters are especially important when an application cooperates with an external system. If such system sends events, it is a good practice to check if an event contains all expected information and if event attribute values are valid. This type of selection could be done in filters. Filters may also prevent from idly processing events that should be ignored by the application logic at early phase as they can have an impact on the whole performance.

=== Triggers
Triggers should be implemented in a way to support concurrent processing of many events by different threads. You should avoid class level (static) variables and restrict, if possible, to data transfered in events.

=== Rules
Rules should be used when triggers functionality is not sufficient for the problem you try to solve.

=== Correlators
Correlators should be used when filters, triggers and rules functionality is not sufficient for the problem you try to solve.

=== Actions
Actions should be created only when there is a need to provide some functionality that is to be used in many knowledge bases that are written in different scripting languages and only when you don't want to write it in Java.


== Scripting languages

[[supported-script-languages]]
=== Supported languages
.Supported knowledge base scripting languages
[width=50%]
|===
|Language |Implementation

|Python
|Jython

|Ruby
|JRuby

|Groovy
|Groovy

|JavaScript
|Nashorn
|===

=== Python

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jython</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

The dependency for Jython used in {sponge} is https://github.com/scijava/jython-shaded[Jython shaded].

=== Ruby

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jruby</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== Groovy

==== Limitations
In Groovy you cannot define a class or a function twice in the same file. If you want to reload an event processor or an action, you have to put it in a separate file and use `EPS.reloadClass()` method. That separate file could be modified and reloaded.

.Example
[source,groovy]
----
void onLoad() {
    EPS.reloadClass(TriggerA)
    EPS.enable(TriggerA)

    EPS.reloadClass(FunctionAAction)
    EPS.enable(FunctionAAction)
    EPS.callAction("FunctionAAction")
}
----

For every knowledge base file there is a new Groovy `Script` instance created. For example when reloading, a new Groovy `Script` instance is created for each knowledge base file and they are placed in a list (in a reverse order) to be used by the {sponge} Groovy interpreter internally.

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-groovy</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== JavaScript
JavaScript interpreter supports https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/shell.html[shell scripting extensions in Nashorn] to provide simpler shell integration.

==== Limitations
There is a limitation for using custom class attributes and methods in event processors written in JavaScript implementation Nashorn. In that case you should set a class field `target` in the `init()` method as in the following example. All class fields and methods that are new (i.e. not inherited from the base classes) *must be defined in `target`*.

.JavaScript target
[source,javascript]
----
var HeartbeatFilter = Java.extend(Filter, {
    configure: function(self) {
        self.event = "heartbeat";
    },
    init: function(self) {
        self.target = new function() { // <1>
            this.heartbeatCounter = 0;
        }
    },
    accepts: function(self, event) {
        self.target.heartbeatCounter++; // <2>
        if (self.target.heartbeatCounter > 2) {
            EPS.removeEvent(hearbeatEventEntry);
            return false;
        } else {
            return true;
        }
    }
});
----
<1> Setting `target` that defines an attribute `heartbeatCounter`.
<2> Using `target` for accessing attribute `heartbeatCounter`.

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-nashorn</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== Logging
{sponge} uses https://www.slf4j.org[SLF4J] facade for logging.

Examples and standalone version use https://logback.qos.ch[Logback] as a logging implementation.

Java-based processors and plugins may use:

* {sponge} logging, by using the `getLogger()` method, e.g. `getLogger().info("logging");`, or
* own loggers defined in their classes, according to the standard conventions, e.g.
+
[source,java]
----
private static final Logger logger = LoggerFactory.getLogger(ConnectionPlugin.class);
...
    logger.info("logging");
}
----

== Examples

=== Complete example projects of embedding {sponge}
The complete projects could be used as a point of reference to embed {sponge} in your Java application. They are placed in `sponge-examples-projects`.

==== News project
This project shows how to process news as events. It is placed in `sponge-examples-project-news` (see {sourcesUrl}/sponge-examples-projects/sponge-examples-project-news[sources]).

Event flow:

* News are manually generated and sent as {sponge} events named `news` in `onStartup` function of the knowledge base named `newsGenerator`. Each event has custom attributes: `source` and `title`.
* Every event named `news` is filtered to discard news that have empty or short (according to `newsFilterWordThreshold` configuration property) titles. This is done by `NewsFilter` filter.
* Events named `news` are logged by `LogNewsTrigger` trigger.
* When there are no new `news` events (that passed filters) for a specified time, then `alarm` event is sent. This is done by `NoNewNewsAlarmRule` rule.
* `LatestNewsCorrelator` correlator listens to `news` events and stores the latest news in `storagePlugin` plugin in a Python `deque`. The number of latest news is configured as `latestNewsMaxSize` property.
* When `alarm` event happens, this fact is logged by `AlarmTrigger` trigger using `echoPlugin` plugin and `EmphasizeAction` action.


.Main class - NewsExampleMain
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-news/src/main/java/org/openksavi/sponge/examples/project/news/NewsExampleMain.java[lines=17..-1]
----

.{sponge} XML configuration file - config.xml
[source,xml]
----
include::{completeExamplesProject}/sponge-examples-project-news/config/config.xml[]
----

.Python-based knowledge base 'main' file - main_event_processors.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_event_processors.py[lines=5..-1]
----

.Python-based knowledge base 'main' file - main_functions.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_functions.py[lines=5..-1]
----

.Python-based knowledge base 'main' file - main_plugins.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_plugins.py[lines=5..-1]
----

.JavaScript-based knowledge base 'actions' file - actions.js
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/actions.js[actions.js]
----

.Python-based knowledge base that generates sample news - news_generator.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/news_generator.py[lines=5..-1]
----

.Java-based plugin class - MultiEchoPlugin
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-news/src/main/java/org/openksavi/sponge/examples/project/news/MultiEchoPlugin.java[lines=17..-1]
----

==== Camel RSS News project
This example is an enhancement over the News project example. It is placed in `sponge-examples-project-camel-rss-news` (see {sourcesUrl}/sponge-examples-projects/sponge-examples-project-camel-rss-news[sources]).

The main change here is that news are acquired as RSS feeds from news services: BBC and CNN. Reading of RSS feeds and transformation to {sponge} events is performed in a Camel route. {sponge} acts as a producer in this Camel route. This example shows {sponge} as a consumer in other Camel routes as well.

This example also presents integration with Spring framework. A service provided as a Spring bean is accessed from the script knowledge base.

Notice that knowledge bases `main` and `actions` that existed in the News project example are not changed. This is because the main processing is independent of the input and output interfaces, protocols or data structures. Internal events (in this case `news` events) are normalized.

Event flow:

* RSS feeds are read from external sources, transformed to {sponge} events and sent to the {sponge} engine. This is done in Camel routes.
* Because of `main` knowledge base is the same as in the previous example, so are the event flow parts here.
* After time configured as a property `durationOfReadingRss` Camel routes that read RSS feeds from external sources are stopped. It simulates lack of new news. This is done in `simulator` knowledge base.
* When `alarm` event happens, not only `AlarmTrigger` (as described in the previous example) handles that event, but here also `ForwardAlarmTrigger` trigger, defined in `consumer` knowledge base. It sends the alarm message to:
** all Camel endpoints that use the Sponge engine as a consumer in their routes,
** to a specific endpoint given as URI.

.Main class - CamelRssNewsExampleMain
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/src/main/java/org/openksavi/sponge/examples/project/camelrssnews/CamelRssNewsExampleMain.java[lines=17..-1]
----

.Spring Java configuration - SpringConfiguration
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/src/main/java/org/openksavi/sponge/examples/project/camelrssnews/SpringConfiguration.java[lines=17..-1]
----

.{sponge} XML configuration file - config.xml
[source,xml]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/config/config.xml[]
----

.Python-based extended configuration - config.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/kb/config.py[lines=5..-1]
----

.Python-based knowledge base that sends messages to Camel as a consumer - consumer.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/kb/consumer.py[lines=5..-1]
----


=== Features examples
The features examples shows how to use certain functionalities. See the sources in {sourcesUrl}/sponge-jython/examples[Python examples], {sourcesUrl}/sponge-jruby/examples[Ruby examples], {sourcesUrl}/sponge-groovy/examples[Groovy examples] and {sourcesUrl}/sponge-nashorn/examples[JavaScript examples].

CAUTION: Not all examples will work in the standalone application because some of them require additional setup.

Directory `examples/script` contains examples implemented in all supported script languages (i.e. example named `rules` is placed respectively in `rules.py`, `rules.rb`, `rules.groovy` and `rules.js`). Each of these examples is also a test case with assertions invoked in the corresponding JUnit class (e.g. `RulesTest.java`).

.Examples of key features for all supported scripting languages
[cols="1,3"]
|===
|Name |Description

|`actions`
ifdef::useReferences[(link:sponge-examples.html#actions-py[py], link:sponge-examples.html#actions-rb[rb], link:sponge-examples.html#actions-groovy[groovy], link:sponge-examples.html#actions-js[js])]
|Shows how to use actions.

|`correlators`
ifdef::useReferences[(link:sponge-examples.html#correlators-py[py], link:sponge-examples.html#correlators-rb[rb], link:sponge-examples.html#correlators-groovy[groovy], link:sponge-examples.html#correlators-js[js])]
|Shows how to use correlators. The script defined correlator creates an event log - a list of all events that it listens to.

|`correlators_duration`
ifdef::useReferences[(link:sponge-examples.html#correlators_duration-py[py], link:sponge-examples.html#correlators_duration-rb[rb], link:sponge-examples.html#correlators_duration-groovy[groovy], link:sponge-examples.html#correlators_duration-js[js])]
|Shows how to use correlators with duration. The script defined correlator creates an event log - a list of all events that it listens to.

|`events_clone_policy`
ifdef::useReferences[(link:sponge-examples.html#events_clone_policy-py[py], link:sponge-examples.html#events_clone_policy-rb[rb], link:sponge-examples.html#events_clone_policy-groovy[groovy], link:sponge-examples.html#events_clone_policy-js[js], link:sponge-examples.html#events_clone_policy-xml-py[XML configuration])]
|Shows difference between event clone policies.

|`events_cron`
ifdef::useReferences[(link:sponge-examples.html#events_cron-py[py], link:sponge-examples.html#events_cron-rb[rb], link:sponge-examples.html#events_cron-groovy[groovy], link:sponge-examples.html#events_cron-js[js])]
|Shows sending events using Cron.

|`events_removing`
ifdef::useReferences[(link:sponge-examples.html#events_removing-py[py], link:sponge-examples.html#events_removing-rb[rb], link:sponge-examples.html#events_removing-groovy[groovy], link:sponge-examples.html#events_removing-js[js])]
|Shows how to remove scheduled events.

|`filters_deduplication`
ifdef::useReferences[(link:sponge-examples.html#filters_deduplication-py[py], link:sponge-examples.html#filters_deduplication-rb[rb], link:sponge-examples.html#filters_deduplication-groovy[groovy], link:sponge-examples.html#filters_deduplication-js[js])]
|Shows how to use a deduplication filter to prevent from processing many events that carry the same information.

|`filters_java`
ifdef::useReferences[(link:sponge-examples.html#filters_java-py[py], link:sponge-examples.html#filters_java-rb[rb], link:sponge-examples.html#filters_java-groovy[groovy], link:sponge-examples.html#filters_java-js[js])]
|Shows how to use a Java-based filter.

|`filters`
ifdef::useReferences[(link:sponge-examples.html#filters-py[py], link:sponge-examples.html#filters-rb[rb], link:sponge-examples.html#filters-groovy[groovy], link:sponge-examples.html#filters-js[js])]
|Shows how to use script-based filters.

|`hello_world`
ifdef::useReferences[(link:sponge-examples.html#hello_world-py[py], link:sponge-examples.html#hello_world-rb[rb], link:sponge-examples.html#hello_world-groovy[groovy], link:sponge-examples.html#hello_world-js[js], link:sponge-examples.html#hello_world-xml-py[XML configuration])]
|Hello world complete example.

|`knowledge_base_callbacks`
ifdef::useReferences[(link:sponge-examples.html#knowledge_base_callbacks-py[py], link:sponge-examples.html#knowledge_base_callbacks-rb[rb], link:sponge-examples.html#knowledge_base_callbacks-groovy[groovy], link:sponge-examples.html#knowledge_base_callbacks-js[js])]
|Shows how to use knowledge base callback functions: `onInit`, `onStartup`, `onShutdown`, `onBeforeReload` and `onAfterReload`.

|`knowledge_base_load`
ifdef::useReferences[(link:sponge-examples.html#knowledge_base_load-py[py], link:sponge-examples.html#knowledge_base_load-rb[rb], link:sponge-examples.html#knowledge_base_load-groovy[groovy], link:sponge-examples.html#knowledge_base_load-js[js])]
|Shows how to load an additional knowledge base file by using `EPS.interpreter.load()`.

|`knowledge_base_manager`
ifdef::useReferences[(link:sponge-examples.html#knowledge_base_manager-py[py], link:sponge-examples.html#knowledge_base_manager-rb[rb], link:sponge-examples.html#knowledge_base_manager-groovy[groovy], link:sponge-examples.html#knowledge_base_manager-js[js])]
|Shows knowledge base operations.

|`library`
ifdef::useReferences[(link:sponge-examples.html#library-py[py], link:sponge-examples.html#library-rb[rb], link:sponge-examples.html#library-groovy[groovy], link:sponge-examples.html#library-js[js], link:sponge-examples.html#library-xml-py[XML configuration])]
|Shows how to use a scripting language specific library (e.g. `httplib` for Python) to check HTTPS host status.

|`plugins_java`
ifdef::useReferences[(link:sponge-examples.html#plugins_java-py[py], link:sponge-examples.html#plugins_java-rb[rb], link:sponge-examples.html#plugins_java-groovy[groovy], link:sponge-examples.html#plugins_java-js[js], link:sponge-examples.html#plugins_java-xml-py[XML configuration])]
|Shows how to define and use a Java-based plugins.

|`plugins_script`
ifdef::useReferences[(link:sponge-examples.html#plugins_script-py[py], link:sponge-examples.html#plugins_script-rb[rb], link:sponge-examples.html#plugins_script-groovy[groovy], link:sponge-examples.html#plugins_script-js[js], link:sponge-examples.html#plugins_script-xml-py[XML configuration])]
|Shows how to define and use a script-based plugins.

|`rules_events`
ifdef::useReferences[(link:sponge-examples.html#rules_events-py[py], link:sponge-examples.html#rules_events-rb[rb], link:sponge-examples.html#rules_events-groovy[groovy], link:sponge-examples.html#rules_events-js[js], link:sponge-examples.html#rules_events-xml-py[XML configuration])]
|Shows how to define and use rules that have different event modes, durations etc.

|`rules_heartbeat`
ifdef::useReferences[(link:sponge-examples.html#rules_heartbeat-py[py], link:sponge-examples.html#rules_heartbeat-rb[rb], link:sponge-examples.html#rules_heartbeat-groovy[groovy], link:sponge-examples.html#rules_heartbeat-js[js])]
|Heartbeat complete example.

|`rules_none_mode_events_conditions`
ifdef::useReferences[(link:sponge-examples.html#rules_none_mode_events_conditions-py[py], link:sponge-examples.html#rules_none_mode_events_conditions-rb[rb], link:sponge-examples.html#rules_none_mode_events_conditions-groovy[groovy], link:sponge-examples.html#rules_none_mode_events_conditions-js[js])]
|Shows how to define and use rules that have `none` event mode and event conditions.

|`rules_none_mode_events`
ifdef::useReferences[(link:sponge-examples.html#rules_none_mode_events-py[py], link:sponge-examples.html#rules_none_mode_events-rb[rb], link:sponge-examples.html#rules_none_mode_events-groovy[groovy], link:sponge-examples.html#rules_none_mode_events-js[js])]
|Shows how to define and use rules that have `none` event mode.

|`rules`
ifdef::useReferences[(link:sponge-examples.html#rules-py[py], link:sponge-examples.html#rules-rb[rb], link:sponge-examples.html#rules-groovy[groovy], link:sponge-examples.html#rules-js[js])]
|Shows how to define and use rules. Event conditions are specified using lambda expressions as well as class methods.

|`triggers`
ifdef::useReferences[(link:sponge-examples.html#triggers-py[py], link:sponge-examples.html#triggers-rb[rb], link:sponge-examples.html#triggers-groovy[groovy], link:sponge-examples.html#triggers-js[js], link:sponge-examples.html#triggers-xml-py[XML configuration])]
|Shows how to define and use triggers.
|===


.Examples for specific languages
[cols="1,3"]
|===
|Name |Description

|`fibonacci`
ifdef::useReferences[(link:sponge-examples.html#fibonacci-py[py])]
|Shows how to send a chain of events, each carrying a Fibonacci number as an attribute.

|`engine_parameters`
ifdef::useReferences[(link:sponge-examples.html#engine_parameters-xml[xml])]
|Shows how to set engine parameters in the XML configuration file.

|`spring`
ifdef::useReferences[(link:sponge-examples.html#spring-py[py], link:sponge-examples.html#spring-java[java])]
|Shows how to integrate with Spring framework.

|`camel_producer`
ifdef::useReferences[(link:sponge-examples.html#camel_producer-py[py], link:sponge-examples.html#camel_producer-java[java])]
|Shows how to handle messages coming from Apache Camel route by a {sponge} trigger.

|`camel_consumer`
ifdef::useReferences[(link:sponge-examples.html#camel_consumer-py[py], link:sponge-examples.html#camel_consumer-java[java])]
|Shows how to handle messages coming from {sponge} by an Apache Camel route.

|`camel_rss`
ifdef::useReferences[(link:sponge-examples.html#camel_rss-py[py], link:sponge-examples.html#camel_rss-java[java])]
|Shows how to integrate with Apache Camel to send and handle {sponge} events based on RSS feeds. This example uses a Spring configuration.

|`camel_producer_overridden_action`
ifdef::useReferences[(link:sponge-examples.html#camel_producer_overridden_action-py[py], link:sponge-examples.html#camel_producer_overridden_action-java[java])]
|Shows how to handle messages coming from Apache Camel route by a {sponge} trigger using an overridden Camel producer action.

|`camel_producer_custom_action`
ifdef::useReferences[(link:sponge-examples.html#camel_producer_custom_action-py[py], link:sponge-examples.html#camel_producer_custom_action-java[java])]
|Shows how to handle messages coming from Apache Camel route by a {sponge} trigger using a custom Camel producer action.

|`camel_multiple_consumer`
ifdef::useReferences[(link:sponge-examples.html#camel_multiple_consumer-py[py], link:sponge-examples.html#camel_multiple_consumer-java[java])]
|Shows sending Camel messages to many endpoints in a single {sponge} trigger.
|===

=== Standalone examples

.Examples for standalone {sponge}
[cols="1,3"]
|===
|Name |Description

|`standalone_news`
ifdef::useReferences[(link:{sourcesUrl}/sponge-examples/examples/standalone/news[sources])]
|This example is based on complete example project of embedding {sponge} - News, but adjusted to a standalone version.

|`standalone_camel_rss_news`
ifdef::useReferences[(link:{sourcesUrl}/sponge-examples/examples/standalone/camel_rss_news[sources])]
|This example is based on complete example project of embedding {sponge} - Camel RSS News, but adjusted to a standalone version.

|`camel_route_groovy`
ifdef::useReferences[(link:{sourcesUrl}/sponge-examples-projects/sponge-examples-project-standalone-camel-groovy[sources])]
|Camel routes in Groovy Spring configuration.

|`camel_route_xml`
ifdef::useReferences[(link:{sourcesUrl}/sponge-examples-projects/sponge-examples-project-standalone-camel-xml[sources])]
|Camel context and routes in XML Spring configuration.
|===

== Maven artifacts

.{sponge} Maven artifacts
[cols="1,1,2"]
|===
|GroupId |ArtifactId |Description

|`org.openksavi.sponge`
|`sponge-parent`
|Parent project.

|`org.openksavi.sponge`
|`sponge-bom`
|Bill Of Materials style pom.xml.

|`org.openksavi.sponge`
|`sponge-api`
|{sponge} API.

|`org.openksavi.sponge`
|`sponge-core`
|{sponge} core implementation. You may use this dependency if you don't need a scripting language support, for example when creating knowledge bases only in Java.

|`org.openksavi.sponge`
|`sponge-jython`
|Support for Python-based scripting knowledge bases using Jython.

|`org.openksavi.sponge`
|`sponge-jruby`
|Support for Ruby-based scripting knowledge bases using JRuby.

|`org.openksavi.sponge`
|`sponge-groovy`
|Support for Groovy-based scripting knowledge bases.

|`org.openksavi.sponge`
|`sponge-nashorn`
|Support for JavaScript-based scripting knowledge bases using Nashorn.

|`org.openksavi.sponge`
|`sponge-camel`
|Apache Camel integration.

|`org.openksavi.sponge`
|`sponge-spring`
|Spring framework integration.

|`org.openksavi.sponge`
|`sponge-standalone`
|Standalone distribution of {sponge}.

|`org.openksavi.sponge`
|`sponge-signal`
|Wrappers for Operating System signals.

|`org.openksavi.sponge`
|`sponge-examples`
|{sponge} examples.

|`org.openksavi.sponge`
|`sponge-examples-projects`
|{sponge} examples - complete projects with embedded {sponge}: `sponge-examples-project-news`, `sponge-examples-project-camel-rss-news`.

|`org.openksavi.sponge`
|`sponge-distribution`
|Contains documentation, release configuration etc.

|`org.openksavi.sponge`
|`sponge-test`
|{sponge} test support.


|`org.openksavi.sponge`
|`sponge-integration-tests`
|Internal integration tests.
|===


include::includes/sponge-user-guide-standalone.adoc[leveloffset=+1]


== Third party software
{sponge} uses third party software released under various open-source licenses.

.Key third party software
[cols="1,1,2"]
|===
|Package |License |Description

|https://commons.apache.org/proper/commons-configuration/[Apache Commons Configuration]
|Apache 2.0
|Used for reading configuration files.

|http://www.jython.org[Jython]
|http://www.jython.org/license.html[Jython license]
|Supports writing scripting knowledge bases in Python.

|http://jruby.org[JRuby]
|EPL 1.0, GPL 2 or LGPL 2.1
|Supports writing scripting knowledge bases in Ruby.

|http://www.groovy-lang.org[Groovy]
|Apache 2.0
|Supports writing scripting knowledge bases in Groovy.

|https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/[Nashorn]
|GPL with a linking exception
|Supports writing scripting knowledge bases in JavaScript.

|http://www.quartz-scheduler.org[Quartz]
|Apache 2.0
|Used for scheduling events (e.g. provides cron functionality).

|http://camel.apache.org[Apache Camel]
|Apache 2.0
|Used as an integration facade to external systems.

|http://projects.spring.io/spring-framework[Spring framework]
|Apache 2.0
|Used for integration with Spring framework.

|https://github.com/google/guava[Guava]
|Apache 2.0
|Used for services and as a utilities library.
|===

The complete list of these libraries may be found in the `THIRD-PARTY.txt` and `licenses.xml` files of the standalone distribution as well as in the source code (Maven dependencies).