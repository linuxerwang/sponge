= User Guide
:page-permalink: /user-guide/
:toc:
:pySourcesUrl: {sourcesUrl}/sponge-jython/examples/script/py/
:rbSourcesUrl: {sourcesUrl}/sponge-jruby/examples/script/rb/
:groovySourcesUrl: {sourcesUrl}/sponge-groovy/examples/script/groovy/
:jsSourcesUrl: {sourcesUrl}/sponge-nashorn/examples/script/js/
:coreSourcesUrl: {sourcesUrl}/sponge-integration-tests/examples/core/
:springSourcesUrl: {sourcesUrl}/sponge-spring/examples/spring/
:camelSourcesUrl: {sourcesUrl}/sponge-camel/examples/camel/

== Introduction
{sponge} is a polyglot system that allows creating knowledge bases in several scripting languages.

For the purpose of clarity, examples in this chapter are written in Python (http://www.jython.org[Jython]) as one of the supported scripting languages and in Java. All examples written in Python may have equivalent ones written in any of the other <<supported-script-languages,supported script languages>>.


include::includes/sponge-user-guide-architecture.adoc[leveloffset=+1]


include::includes/sponge-user-guide-configuration.adoc[leveloffset=+1]

== Engine

=== Starting up
To startup the engine you should invoke the `startup()` method. After startup, the engine runs in the background (i.e. using threads other than the current one) until you shutdown it.

.Example of starting up
[source,java]
----
Engine engine = DefaultEngine.builder().config("examples/script/py/hello_world.xml").build();
engine.startup();
----

=== Shutting down

When a {sponge} instance is no longer needed it should be shut down by invoking `shutdown()` or `requestShutdown()` method. It instructs the engine to do some clean up, stop all managed threads, free resources, etc. The `shutdown()` uses the current thread to stop the engine. The `requestShutdown()` uses a new thread to stop the engine, thus allowing to shutdown the engine from the within, e.g. form an event processor.

.Example of shutting down in Java
[source,java]
----
engine.shutdown();
----

.Example of shutting down in a script language
[source,python]
----
class SomeTrigger(Trigger):
    def onConfigure(self):
        self.event = "e1"
    def onRun(self, event):
        EPS.requestShutdown()
----

Shutting down doesn't guarantee that all events sent to the engine will be processed. However, all events that have already been read from the Input Event Queue (by the Filter Processing Unit) will be fully processed by the engine, if the processing doesn't exceed shutdown timeouts (specified by the `executorShutdownTimeout` configuration parameter). All newer events remaining in the Input Event Queue will not be processed at all.

include::includes/sponge-user-guide-knowledge-bases.adoc[leveloffset=+1]


== Events
Events are the basic element of processing in {sponge}. They have properties such as id, name and send time. The name of an event is also the type of this event. All events than have the same name belong to the same type. Event names should follow Java naming conventions for variable names. Events may have any number of attributes. These attributes will be available, for example, in event processors.

{sponge} supports only point-in-time events.

=== Properties and methods

.Event properties and methods
[cols="1,4"]
|===
|Property / Method |Description

|`id`
|A property that is a global unique identifier of an event (String). This is a shortcut for `getId()`/`setId(text)` methods.

|`name`
|A read-only property that is the name (type) of an event. This is a shortcut for the `getName()` method. A name of an event shouldn't be changed after the event has been created.

|`time`
|A property that is a send time of an event, i.e. a time of adding an event to the Input Event Queue. The time is represented as `java.time.Instant`. This is a shortcut for `getTime()`/`setTime(instant)` methods.

|`set(attributeName, value)`
|A method that allows setting an attribute of an event.

|`Object get(attributeName)`
|A method that returns a value of an attribute or `null` if it does't exist.

|`Object get(attributeName, attributeClass)`
|A method that returns a value of an attribute (assuming it is an instance of `attributeClass`) or `null` if it does't exist.

|`boolean has(attributeName)`
|A method that checks if an event has an attribute.

|`all`
|A property that returns a map of all attributes. This is a shortcut for the `getAll()` method.

|`Event clone()`
|A method that clones an event.
|===

Properties `id` and `time` are automatically set when adding an event to the Input Event Queue and there is no need for setting them manually.

=== Event queues
You may see ignored events (i.e. events that go to the Output Event Queue) in the logs by setting the `sponge.event.ignored` logger to `INFO`.

=== Event priorities
A priority may be assigned only to control events, that are used internally by the engine. For standard events the priority always equals to `0` and cannot be modified.

A priority defines a level of the importance of an event. Events are added to and taken from queues with respect to their priorities. Priority is a positive or negative integer and the higher the number is, the higher is the priority of an event and the event will be processed before the others.

=== Typical event processing
In order to process an event there must be an event processor listening to events of that type (the types of events are recognized by their names). So this steps should be taken:

* Creating an event processor.
* Enabling the event processor automatically or manually (by invoking a proper `EPS.enable*()` method).
* Creating a new event instance and sending it to the system (e.g. `EPS.event("alarm").set("location", "Building 1").send()`.
* The event goes directly to the Input Event Queue or is scheduled to be inserted to the Input Event Queue later. Scheduling is performed by the Event Scheduler.
* From this queue the events are taken by the Filter Processing Unit. The list of filters defined for this event type is taken and then each of them is invoked. If all filters accept the event, it will be put to the Main Event Queue in which it will await to be processed by other event processors.
* Then the event is collected by the Main Processing Unit. The list of event processors listening to this type of events is selected and then each of them is given the event to process.
* After processing by the Main Processing Unit the event goes to the Output Event Queue if and only if it hasn't been processed (i.e. listened to) by any of event processors.

=== Event cloning
The event is cloned each time when the periodically generated events are sent to the Input Event Queue.

The standard implementation of events allows choosing the cloning policy `shallow` or `deep`. These policies differ in the way of cloning of events attributes. When using the former, the references to attributes are copied - each event processor works on the same attribute instances. The policy `deep` executes the procedure of deep cloning, so each next generated event will contain individual copies of the attributes.

=== Custom events
The default implementation of an event is the `AttributeMapEvent` class. However, {sponge} allows to use custom event implementations of the `Event` interface.

=== Creating and sending events
*Creating an event means creating an instance of an event class. Sending an event means that the created event will be put into the Input Event Queue, to be processed by filters and then by triggers, rules and correlators.*

Event could be created and sent:

* Using the EventDefinition fluent API (e.g. `EPS.event("helloEvent").set("say", "Hello World!").send()`). The method `EPS.event` returns `EventDefinition`.
* Using the traditional API (e.g. `EPS.send(EPS.makeEvent("helloEvent").set("say", "Hello World!"))`).

The EventDefinition fluent API is the preferred option.

An event may be to sent as:

* A single instance – the event will be placed in the Input Event Queue only once.
* Many instances periodically – new instances of an event will be placed in the Input Event Queue periodically, each of them with its own id and send time.

.`EventDefinition` methods
[cols="1,4"]
|===
|Method |Description

|`EventDefinition set(String name, Object value)`
|Sets the event attribute.

|`EventDefinition modify(EventDefinitionModifier modifier)`
|Modifies the underlying event.

|`send()`
|Sends an event immediately.

|`sendAfter(delay)`
|Sends an event after the specified time (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]).

|`sendAfter(delay, interval)`
|Periodically sends events after the specified time (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]) every `interval` (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]).

|`sendAt(at)`
|Sends an event at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970 or as an {javaSeJavaDocUrl}/java/time/Instant.html[`Instant`]).

|`sendAt(at, interval)`
|Periodically sends events starting at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970 or as an {javaSeJavaDocUrl}/java/time/Instant.html[`Instant`]) every `interval` (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]).

|`sendAt(crontabSpec)`
|Sends events at time specified by Cron compatible time entry.

|`Event make()`
|Only returns the newly created event without sending.
|===

=== Control events
Control events are used by the engine internally. The names of control events have a prefix `$`. You shouldn't give to your standard event a name that starts with this character.

=== Examples of sending events
Sample sending of events from the level of a knowledge base:

[source,python]
----
EPS.event("e1").sendAfter(Duration.ofSeconds(1))
----
Sends the event named `"e1"` after `1` second from now.

[source,python]
----
EPS.event("e2").sendAfter(2000, 1000)
----
Sends the event named `"e2"` after `2` seconds from now. New events will be periodically generated and sent every second.

[source,python]
----
EPS.event("e2").set("color", "red").set("severity", 5).send()
----
Sends an event with attributes `"color"` and `"severity"` immediately.

[source,python]
----
EPS.event("alarm").sendAt("0-59 * * * * ?")
----
Sends an event at the time specified by Cron notation.

== Processors
Processors are the basic objects that you define in {sponge} to implement your knowledge base behavior.

Types of processors:

* *Event processors* - processors that perform specified operations using events they listen to.
** *Filters* - event processors used for allowing only certain events to be later processed by other event processors.
** *Triggers* -  event processors that execute a specified code when an event happens.
** *Event set processors* - event processors that process sets of events.
*** *Rules* - event set processors that detect sequences of events.
*** *Correlators* - event set processors that detect any set of events and could be also used for implementing any complex event processing that isn't provided by filters, triggers or rules.
* *Actions* - processors that provide functionality similar to functions. They don't listen to events.

=== Creating processors
In order to define your processor in a script knowledge base, you have to create a class extending the base class pointed by a specific alias (e.g. `Filter` for filters). In order to define your processor in a Java knowledge base, you have to create a class extending a specific class (e.g. `JavaFilter` for filters).

A name of a processor is a name of a class defining this processor.

=== Enabling processors
The operation of registering a processor in the engine is called enabling. Registered processors are available to the engine to perform specific tasks. For example, after enabling an event processor starts listening to events it is interested in.

Processors could be enabled:

* by auto-enable (this is the default setting for script-based processors),
* manually.

==== Auto-enable
{sponge} automatically enables all processors (i.e. actions, filters, triggers, rules and correlators) defined in a script knowledge base. This is done just before invoking the `onLoad` callback function in the knowledge base. Processor classes whose names start with the `Abstract` prefix are considered abstract and will not be automatically enabled.

CAUTION: Processors defined in script knowledge bases have to extend the correct base classes, otherwise they will not be enabled automatically.

As previously mentioned, the auto-enable feature scans only for processors defined in the scripting knowledge base. Enabling Java-based processors has to be done manually.

.Example of processor inheritance and auto-enable
[source,python]
----
# This abstract action will not be automatically enabled.
class AbstractCalculateAction(Action):
    def calculateResult(self, args):
        return 1

# This action will be automatically enabled.
class CalculateAction(AbstractCalculateAction):
    def onCall(self, args):
        return self.calculateResult(args) * 2
----

You may turn off auto-enable by setting the `autoEnable` engine configuration parameter to `false` (for example in the Sponge XML configuration file). In that case you have to enable processors manually.

==== Manual enabling
In most cases enabling processors manually should be done in the `onLoad` callback function.

To manually enable any script-based processors in a script knowledge base you may use: `EPS.enable()` to enable one processor and `EPS.enableAll()` to enable many processors.

.Example of enabling a script-based processor
[source,python]
----
def onLoad:
    EPS.enable(TriggerA)
----

.Example of enabling script-based processors
[source,python]
----
def onLoad:
    EPS.enableAll(Trigger1, Trigger3)
----

To manually enable any Java-based processors in a script knowledge base you may use `EPS.enableJava()` and `EPS.enableJavaAll()`. The default name of a Java-based processor is its full Java class name.

.Example of enabling a Java-based processor
[source,python]
----
def onLoad():
    EPS.enableJava(SameSourceJavaRule)
----

=== Disabling processors
Processors could be disabled only manually. To disable any script-based processors in a script knowledge base you may use `EPS.disable()` to disable one processor and `EPS.disableAll()` to disable many processors.

.Example of disabling a script-based processor
[source,python]
----
def onLoad:
    EPS.disable(EchoAction)
----

To disable any Java-based processors in a script knowledge base you may use `EPS.disableJava()` and `EPS.disableJavaAll()`.

.Example of disabling a Java-based processor
[source,python]
----
def onLoad():
    EPS.disableJava(SameSourceJavaRule)
----

=== Properties and methods

[[processor-methods]]
.Processor properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|*`onConfigure()`*
|The configuration callback method that will be invoked when a processor is being enabled. This method is mandatory.

|`onInit()`
|The initialization callback method that will be invoked after `onConfigure()`, each time a new working instance of the processor is created.

|`name`
|The property that is a name of the processor. This is a shortcut for `getName()`/`setName(text)` methods. Because of names of processors are created automatically, the setter shouldn't be used in a client code.

|`displayName`
|The property that is a display name of a processor. This is a shortcut for `getDisplayName()`/`setDisplayName(text)` methods. A display name is not used internally but may be useful for a client code.

|`logger`
|The read-only property that provides a processor logger. This is a shortcut for `getLogger()` method. A processor logger name has the following format: `sponge.kb.<language>.<knowledgeBaseName>.<processorName>`, e.g. `sponge.kb.python.kb1.EchoAction` for a python-based processor, `sponge.kb.python.kb1.org.openksavi.sponge.examples.PowerEchoAction` for a Java-based processor enabled in a Python-based knowledge base.

|`adapter`
|The read-only property that provides a processor adapter. This is a shortcut for `getAdapter()` method. A processor adapter is an internal object, associated with the processor, that is used by the engine. There should be no need to use this property in the client code.
|===

Thanks to many scripting languages, properties may be accessed using dot notation rather than a direct method call. For example a display name may be set using `self.displayName = "Display name"` or `self.setDisplayName("Display name")`.

include::includes/sponge-user-guide-event-processors.adoc[leveloffset=+1]


== Actions
Actions provide functionality similar to functions. They may be used in many knowledge bases that are written in different languages.

The alias for the base class for script-based actions is `Action`. The base class for Java-based actions is `JavaAction`.

=== Properties and methods
In addition to the inherited <<processor-methods,processor properties and methods>>, actions provide the following ones.

.Action properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`Object onCall(args)`
|The callback method invoked when an action is called, e.g.: `EPS.callAction()`. The argument in an array of `Object`s and the result in an `Object`. This method is mandatory.
|===

The `onConfigure` method in actions is not mandatory.

Every action should implement the abstract `onCall` method.

=== Example in a script language
The code presented below defines the action named `EchoAction` that simply returns all arguments.

.Action example
[source,python]
----
class EchoAction(Action): # <1>
    def onCall(self, args): # <2>
        return args

def onStartup():
    result = EPS.callAction("EchoAction", 1, "test") # <3>
    logger.debug("Action returned: {}", result)
----
<1> The definition of the action `EchoAction`. The action is represented by the class of the same name.
<2> The action `onCall` callback method.
<3> Calls the action named `"EchoAction"` passing two arguments.

.Console output
----
Action returned: [1, test]
----

=== Example in Java
The code presented below defines the Java-based action named `JavaEchoAction`.

.Java action example
[source,java]
----
public class JavaEchoAction extends JavaAction { // <1>

    @Override
    public Object onCall(Object... args) { // <2>
        return args;
    }
}
----
<1> The definition of the action `JavaEchoAction`. The action is represented by the Java class of the same name.
<2> The action `onCall` callback method.

.Java action manual registration in the Python knowledge base
[source,python]
----
EPS.enableJava(JavaEchoAction)
----


== Plugins
Plugins are used for expanding {sponge} with new functionalities and use them in knowledge bases. Typically they provide access to and from external systems.

The alias for the base class for script-based plugins is `Plugin`. The base class for Java-based plugins is `JavaPlugin`.

Each of these base classes extends the `BasePlugin` class that provides empty implementations of callback methods. If the created plugin requires own configuration parameters (e.g. in the XML configuration file) the `onConfigure` method should be implemented.

Each plugin is also an engine module and that means that in inherits from the `BaseEngineModule` class.

Plugins could be written in Java or in a supported scripting language as a part of a scripting knowledge base. However plugins written in a scripting language must be used only in the same scripting knowledge base they were defined in. That is because there are limitations of scripting languages interoperation. Only plugins written in Java could be used in any scripting knowledge base.

=== Properties and methods

.Plugin properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`name`
|The property that is a name of a plugin. This is a shortcut for `getName()`/`setName(text)` methods. Because of names of plugins are created automatically, the setter shouldn't be used in a client code.

|`onConfigure(Configuration configuration)`
|The configuration callback method that will be invoked after a plugin has been loaded. This method allows reading an XML configuration for the plugin.

|`onInit()`
|The initialization callback method that will be invoked after a configuration of a plugin.

|`onStartup()`
|The callback method that will be invoked once after the startup of the engine.

|`onShutdown()`
|The callback method that will be invoked once before the shutdown of the engine.

|`onBeforeReload()`
|The callback method that will be invoked before every reloading of a knowledge base.

|`onAfterReload()`
|The callback method that will be invoked after every reloading of a knowledge base.

|`logger`
|The read-only property that provides a plugin logger. This is a shortcut for `getLogger()` method. A plugin logger name has the following format: `sponge.kb.plugin.<pluginName>`. Example logger name: `sponge.kb.plugin.scriptPlugin`.
|===


=== Example in Java

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="http://sponge.openksavi.org" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://sponge.openksavi.org http://sponge.openksavi.org/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase" type="python">
            <file>plugins_java.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="echoPlugin" class="org.openksavi.sponge.examples.EchoPlugin">
            <configuration>
                <echo>Echo test!</echo>
                <count>2</count>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

This plugin definition section contains:

* The unique name of the plugin. This name may be used in knowledge bases as a variable referencing this plugin instance.
* The class name of the plugin. It could be a Java class name or a scripting language class name. If the plugin is defined in a scripting knowledge base than you must specify that knowledge base name as an XML tag `<knowledgeBaseName>`.
* Custom configuration for a plugin. That section could be any XML that is understood by this plugin.

The above configuration defines a plugin implemented by `org.openksavi.sponge.examples.EchoPlugin` class. This plugin may be used in the knowledge base as a global variable named `echoPlugin` (according to the `name` attribute). There are additional configuration parameters defined for this plugin. These parameters could be read in the `onConfigure()` method of the plugin class, called before starting the plugin.

.Java plugin example
[source,java]
----
public class EchoPlugin extends JavaPlugin { // <1>

    private static final Logger logger = LoggerFactory.getLogger(EchoPlugin.class);

    private String echo = "noecho";

    private int count = 1;

    public EchoPlugin() {
    }

    @Override
    public void onConfigure(IConfiguration configuration) {  // <2>
        echo = configuration.getString("echo", echo);
        count = configuration.getInteger("count", count);
    }

    @Override
    public void onInit() {  // <3>
        logger.debug("Initializing {}", getName());
    }

    @Override
    public void onStartup() { // <4>
        logger.debug("Starting up {}", getName());
    }

    public String getEcho() {
        return echo;
    }

    public void setEcho(String echo) {
        this.echo = echo;
    }

    public int getCount() {
        return count;
    }

    public String getEchoConfig() {
        return echo + " x " + count;
    }

    public void sendEchoEvent() {
        getEps().event("echoEvent").set("echo", getEcho()).send();
    }
}
----
<1> The definition of the plugin class.
<2> The plugin configuration callback method.
<3> The plugin initialization callback method.
<4> The plugin startup callback method.

=== Using plugins

.Using plugin in a script knowledge base
[source,python]
----
class PluginTrigger(Trigger):
    def onConfigure(self):
        self.event = "e1"
    def onRun(self, event):
        self.logger.debug("Echo from the plugin: {}", echoPlugin.echo) # <1>
----
<1> Obtaining `echo` bean property from the plugin that is an instance of the class `EchoPlugin`.

An access to the plugin could be achieved in two ways:

* directly using the name `echoPlugin` as any other scripting language variable (this is the preferred way),
* by using `EPS` API, e.g. `plugin = EPS.getPlugin("echoPlugin")`.

Because `echoPlugin` implements the method `getEcho()`, you may invoke it in two ways:

* `EPS.getPlugin("echoPlugin").echo`
* `echoPlugin.echo`

=== Example in a script language

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="http://sponge.openksavi.org" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://sponge.openksavi.org http://sponge.openksavi.org/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase" type="python">
            <file>plugins_script.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="scriptPlugin" class="ScriptPlugin" knowledgeBaseName="sampleKnowledgeBase">
            <configuration>
                <storedValue>Value A</storedValue>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

.Scripting language plugin example
[source,python]
----
class ScriptPlugin(Plugin):
    def onConfigure(self, configuration):
        self.storedValue = configuration.getString("storedValue", "default")
    def onInit(self):
        self.logger.debug("Initializing {}", self.name)
    def onStartup(self):
        self.logger.debug("Starting up {}", self.name)
    def getStoredValue(self):
        return self.storedValue
    def setStoredValue(self, value):
        self.storedValue = value
----

=== Plugin life cycle
{sponge} loads plugins when starting the system according to the steps:

. Creates the plugin class instance. The class must have a no-parameter constructor.
. Configures the plugin by invoking the method `onConfigure()`.
. Initializes the plugin by invoking the method `onInit()`.
. Invokes the callback method `onStartup()` when starting the engine.
. After starting all plugins the methods `onStartup()` defined in all knowledge bases are invoked.
. In case of reloading a knowledge base, the method `onBeforeReload()` of each plugin is invoked before the method `onBeforeReload()` of knowledge bases. Invoking the methods `onAfterReload()` goes in reverse (first the methods `onAfterReload()` of all knowledge bases and then the methods defined in plugins).
. Before {sponge} shuts down, methods `onShutdown()` of all knowledge bases are invoked and then the method `onShutdown()` is invoked for each plugin.


== Exception handling
{sponge} introduces its own runtime exception defined as a Java class `SpongeException`. Exception handling in custom Java components (for example plugins) should follow standard Java conventions. Exception handling in scripting knowledge bases should follow standard conventions for the corresponding scripting language.

== Embedding {sponge} in custom applications
{sponge} may be embedded in a custom Java application using <<engine-builder-api,Engine Builder API>>.

include::includes/sponge-user-guide-integration.adoc[leveloffset=+1]

== Best practices
When developing an application using {sponge} you have to be aware of the fact that knowledge bases could be created in two categories of programming languages:

* Java,
* supported scripting languages (e.g. Python, Ruby, Groovy, JavaScript).

Each of these two categories has its pros and cons which makes it better for a certain use. For example scripting languages work well when flexible modification of source code is required.

Libraries written in Java or supported scripting languages may be used, however make sure that they are compatible with the implementations of these languages.

The following chapters describe the best practices for typical use cases.

=== Events
{sponge} is used for developing applications based on event processing. That is why you should start with defining event types. Events should contain enough information (in the form of attributes) so that event processors could provide demanded logic. Moreover, if necessary, you should consider using event chaining, i.e. sending events of a more abstract level based on correlations of low level events.

=== Plugins
If there is a need for creating an interface to an external system, the best way is to use existing or create a new plugin. Once written plugin could be used in other {sponge} based applications.

*In most cases a CamelPlugin, by providing access to all Camel components, should be sufficient when integrating with various systems.*

If there is a need for creating a custom plugin, in most use cases we suggest creating it in Java rather than in a scripting language.

=== Processors
When defining a processor that is not a singleton, its class implementation should provide lightweight creating of new instances.

=== Filters
Filters are especially important when an application cooperates with an external system. If such system sends events, it is a good practice to check if an event contains all expected information and if event attribute values are valid. This type of selection could be done in filters. Filters may also prevent from idly processing events that should be ignored by the application logic at an early phase as they can have an impact on the whole performance.

=== Triggers
Triggers should be implemented in a way to support concurrent processing of many events by different threads. You should avoid class level (static) variables and restrict, if possible, to data transfered in events.

=== Rules
Rules should be used when triggers functionality is not sufficient.

=== Correlators
Correlators should be used when filters, triggers and rules functionality is not sufficient for the problem you try to solve.

=== Actions
Actions should be created only when there is a need to provide some functionality that is to be used in many knowledge bases that are written in different scripting languages and only when you don't want to write it in Java.


== Scripting languages

[[supported-script-languages]]
=== Supported scripting languages
.Supported knowledge base scripting languages
[width=50%]
|===
|Language |Implementation

|Python
|Jython

|Ruby
|JRuby

|Groovy
|Groovy

|JavaScript
|Nashorn
|===

=== Python

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jython</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

The dependency for Jython used in {sponge} is https://github.com/scijava/jython-shaded[Jython shaded].

=== Ruby

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jruby</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== Groovy

==== Limitations
In Groovy you cannot define a class or a function twice in the same file. If you want to prepare a processor to reload, you have to put it in a separate file and use `EPS.reloadClass()` method. That separate file could be modified and reloaded.

.Example
[source,groovy]
----
void onLoad() {
    EPS.reloadClass(TriggerA)
    EPS.enable(TriggerA)

    EPS.reloadClass(ActionA)
    EPS.enable(ActionA)
    EPS.callAction("ActionA")
}
----

For every knowledge base file there is a new Groovy `Script` instance created. For example when reloading, a new Groovy `Script` instance is created for each knowledge base file and they are placed in a list (in a reverse order) to be used by the {sponge} Groovy interpreter internally.

It seems that a Groovy-based knowledge base must have at east one function (may be empty). Otherwise you may get `org.codehaus.groovy.runtime.metaclass.MissingMethodExceptionNoStack` exception.

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-groovy</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== JavaScript
JavaScript interpreter supports https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/shell.html[shell scripting extensions in Nashorn] to provide simpler shell integration.

==== Limitations

===== Custom class attributes and methods
There is a limitation for using custom class attributes and methods in processors written in JavaScript implementation Nashorn. In that case you should set a class field `target` in the `onInit()` method as in the following example. All class fields and methods that are new (i.e. not inherited from the base classes) *must be defined in `target`*.

.JavaScript target
[source,javascript]
----
var HeartbeatFilter = Java.extend(Filter, {
    onConfigure: function(self) {
        self.event = "heartbeat";
    },
    onInit: function(self) {
        self.target = new function() { // <1>
            this.heartbeatCounter = 0;
        }
    },
    onAccept: function(self, event) {
        self.target.heartbeatCounter++; // <2>
        if (self.target.heartbeatCounter > 2) {
            EPS.removeEvent(hearbeatEventEntry);
            return false;
        } else {
            return true;
        }
    }
});
----
<1> Setting `target` that defines an attribute `heartbeatCounter`.
<2> Using `target` for accessing attribute `heartbeatCounter`.

===== Abstract processors

The support for abstract processors is not implemented for processors written in JavaScript.

==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-nashorn</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== Logging
{sponge} uses https://www.slf4j.org[SLF4J] facade for logging.

Examples and standalone version use https://logback.qos.ch[Logback] as a logging implementation.

Java-based processors and plugins may use:

* {sponge} logging, by using the `getLogger()` method, e.g. `getLogger().info("logging")`, or
* own loggers defined in their classes, according to the standard conventions, e.g.
+
[source,java]
----
private static final Logger logger = LoggerFactory.getLogger(ConnectionPlugin.class);
...
    logger.info("logging");
}
----

== Examples

=== Complete example projects of embedding {sponge}
The complete projects could be used as a point of reference to embed {sponge} in your Java application. They are placed in `sponge-examples-projects`.

==== News project
This project shows how to process news as events. It is placed in `sponge-examples-project-news` (see {sourcesUrl}/sponge-examples-projects/sponge-examples-project-news[sources]).

Event flow:

* News are manually generated and sent as {sponge} events named `news` in `onStartup` function of the knowledge base named `newsGenerator`. Each event has custom attributes: `source` and `title`.
* Every event named `news` is filtered to discard news that have empty or short (according to `newsFilterWordThreshold` configuration property) titles. This is done by `NewsFilter` filter.
* Events named `news` are logged by `LogNewsTrigger` trigger.
* When there are no new `news` events (that passed filters) for a specified time, then `alarm` event is sent. This is done by `NoNewNewsAlarmRule` rule.
* `LatestNewsCorrelator` correlator listens to `news` events and stores the latest news in `storagePlugin` plugin in a Python `deque`. The number of latest news is configured as `latestNewsMaxSize` property.
* When `alarm` event happens, this fact is logged by `AlarmTrigger` trigger using `echoPlugin` plugin and `EmphasizeAction` action.


.Main class - NewsExampleMain
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-news/src/main/java/org/openksavi/sponge/examples/project/news/NewsExampleMain.java[lines=17..-1]
----

.{sponge} XML configuration file - config.xml
[source,xml]
----
include::{completeExamplesProject}/sponge-examples-project-news/config/config.xml[]
----

.Python-based knowledge base 'main' file - main_event_processors.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_event_processors.py[lines=5..-1]
----

.Python-based knowledge base 'main' file - main_functions.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_functions.py[lines=5..-1]
----

.Python-based knowledge base 'main' file - main_plugins.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_plugins.py[lines=5..-1]
----

.JavaScript-based knowledge base 'actions' file - actions.js
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/actions.js[actions.js]
----

.Python-based knowledge base that generates sample news - news_generator.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/news_generator.py[lines=5..-1]
----

.Java-based plugin class - MultiEchoPlugin
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-news/src/main/java/org/openksavi/sponge/examples/project/news/MultiEchoPlugin.java[lines=17..-1]
----

==== Camel RSS News project
This example is an enhancement over the News project example. It is placed in `sponge-examples-project-camel-rss-news` (see {sourcesUrl}/sponge-examples-projects/sponge-examples-project-camel-rss-news[sources]).

The main change here is that news are acquired as RSS feeds from news services: BBC and CNN. Reading RSS feeds and transformation to {sponge} events is performed in a Camel route. {sponge} acts as a producer in this Camel route. This example shows {sponge} as a consumer in other Camel routes as well.

This example also presents integration with Spring framework. A service provided as a Spring bean is accessed from the script knowledge base.

Knowledge bases `main` and `actions` that existed in the News project example are not changed. This is because the main processing is independent of the input and output interfaces, protocols or data structures. Internal events (in this case `news` events) are normalized.

Event flow:

* RSS feeds are read from external sources, transformed to {sponge} events and sent to the {sponge} engine. This is done in Camel routes.
* The `main` knowledge base related event flow is the same as in the previous example.
* After the time configured as a property `durationOfReadingRss` Camel routes that read RSS feeds from external sources are stopped. It simulates lack of new news. This is done in the `simulator` knowledge base.
* When `alarm` event happens, not only `AlarmTrigger` (as described in the previous example) handles that event, but here also `ForwardAlarmTrigger` trigger, defined in the `consumer` knowledge base. It sends an alarm message to:
** all Camel endpoints that use the Sponge engine as a consumer in their routes,
** to a specific endpoint given as URI.

.Main class - CamelRssNewsExampleMain
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/src/main/java/org/openksavi/sponge/examples/project/camelrssnews/CamelRssNewsExampleMain.java[lines=17..-1]
----

.Spring Java configuration - SpringConfiguration
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/src/main/java/org/openksavi/sponge/examples/project/camelrssnews/SpringConfiguration.java[lines=17..-1]
----

.{sponge} XML configuration file - config.xml
[source,xml]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/config/config.xml[]
----

.Python-based extended configuration - config.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/kb/config.py[lines=5..-1]
----

.Python-based knowledge base that sends messages to Camel as a consumer - consumer.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/kb/consumer.py[lines=5..-1]
----


=== Scripting examples
The scripting examples show how to use certain {sponge} functionalities in script knowledge bases. See the sources in {sourcesUrl}/sponge-jython/examples/script/py[Python examples], {sourcesUrl}/sponge-jruby/examples/script/rb[Ruby examples], {sourcesUrl}/sponge-groovy/examples/script/groovy[Groovy examples] and {sourcesUrl}/sponge-nashorn/examples/script/js[JavaScript examples].

Each of these examples is also used in the corresponding JUnit class as a test case with assertions. Note that not all of these examples will work in the standalone application because some of them require additional setup.

.Scripting examples
[cols="1,3"]
|===
|Name |Description

|`actions`
ifdef::useReferences[({pySourcesUrl}/actions.py[py], {rbSourcesUrl}/actions.rb[rb], {groovySourcesUrl}/actions.groovy[groovy], {jsSourcesUrl}/actions.js[js])]
|Shows how to use actions.

|`correlators`
ifdef::useReferences[({pySourcesUrl}/correlators.py[py], {rbSourcesUrl}/correlators.rb[rb], {groovySourcesUrl}/correlators.groovy[groovy], {jsSourcesUrl}/correlators.js[js])]
|Shows how to use correlators. The correlator creates an event log - a list of events that it listens to.

|`correlators_duration`
ifdef::useReferences[({pySourcesUrl}/correlators_duration.py[py], {rbSourcesUrl}/correlators_duration.rb[rb], {groovySourcesUrl}/correlators_duration.groovy[groovy], {jsSourcesUrl}/correlators_duration.js[js])]
|Shows how to use correlators with duration.

|`events_clone_policy`
ifdef::useReferences[({pySourcesUrl}/events_clone_policy.py[py], {rbSourcesUrl}/events_clone_policy.rb[rb], {groovySourcesUrl}/events_clone_policy.groovy[groovy], {jsSourcesUrl}/events_clone_policy.js[js], {pySourcesUrl}/events_clone_policy.xml[XML configuration])]
|Shows event clone policies.

|`events_cron`
ifdef::useReferences[({pySourcesUrl}/events_cron.py[py], {rbSourcesUrl}/events_cron.rb[rb], {groovySourcesUrl}/events_cron.groovy[groovy], {jsSourcesUrl}/events_cron.js[js])]
|Shows sending events using Cron.

|`events_removing`
ifdef::useReferences[({pySourcesUrl}/events_removing.py[py], {rbSourcesUrl}/events_removing.rb[rb], {groovySourcesUrl}/events_removing.groovy[groovy], {jsSourcesUrl}/events_removing.js[js])]
|Shows how to remove scheduled events.

|`filters_deduplication`
ifdef::useReferences[({pySourcesUrl}/filters_deduplication.py[py], {rbSourcesUrl}/filters_deduplication.rb[rb], {groovySourcesUrl}/filters_deduplication.groovy[groovy], {jsSourcesUrl}/filters_deduplication.js[js])]
|Shows how to use a deduplication filter to prevent from processing many events that carry the same information.

|`filters_java`
ifdef::useReferences[({pySourcesUrl}/filters_java.py[py], {rbSourcesUrl}/filters_java.rb[rb], {groovySourcesUrl}/filters_java.groovy[groovy], {jsSourcesUrl}/filters_java.js[js])]
|Shows how to use a Java-based filter.

|`filters`
ifdef::useReferences[({pySourcesUrl}/filters.py[py], {rbSourcesUrl}/filters.rb[rb], {groovySourcesUrl}/filters.groovy[groovy], {jsSourcesUrl}/filters.js[js])]
|Shows how to use script-based filters.

|`hello_world`
ifdef::useReferences[({pySourcesUrl}/hello_world.py[py], {rbSourcesUrl}/hello_world.rb[rb], <{groovySourcesUrl}/hello_world.groovy[groovy], {jsSourcesUrl}/hello_world.js[js], {pySourcesUrl}/hello_world.xml[XML configuration])]
|Hello world complete example.

|`knowledge_base_callbacks`
ifdef::useReferences[({pySourcesUrl}/knowledge_base_callbacks.py[py], {rbSourcesUrl}/knowledge_base_callbacks.rb[rb], {groovySourcesUrl}/knowledge_base_callbacks.groovy[groovy], {jsSourcesUrl}/knowledge_base_callbacks.js[js])]
|Shows how to use knowledge base callback functions.

|`knowledge_base_load`
ifdef::useReferences[({pySourcesUrl}/knowledge_base_load.py[py], {rbSourcesUrl}/knowledge_base_load.rb[rb], {groovySourcesUrl}/knowledge_base_load.groovy[groovy], {jsSourcesUrl}/knowledge_base_load.js[js])]
|Shows how to load an additional knowledge base file.

|`knowledge_base_manager`
ifdef::useReferences[({pySourcesUrl}/knowledge_base_manager.py[py], {rbSourcesUrl}/knowledge_base_manager.rb[rb], {groovySourcesUrl}/knowledge_base_manager.groovy[groovy], {jsSourcesUrl}/knowledge_base_manager.js[js])]
|Shows knowledge base operations.

|`library`
ifdef::useReferences[({pySourcesUrl}/library.py[py], {rbSourcesUrl}/library.rb[rb], {groovySourcesUrl}/library.groovy[groovy], {jsSourcesUrl}/library.js[js], {pySourcesUrl}/library.xml[XML configuration])]
|Shows how to use a scripting language specific library (e.g. `httplib` for Python) to check HTTPS host status.

|`plugins_java`
ifdef::useReferences[({pySourcesUrl}/plugins_java.py[py], {rbSourcesUrl}/plugins_java.rb[rb], {groovySourcesUrl}/plugins_java.groovy[groovy], {jsSourcesUrl}/plugins_java.js[js], {pySourcesUrl}/plugins_java.xml[XML configuration])]
|Shows how to define and use a Java-based plugin.

|`plugins_script`
ifdef::useReferences[({pySourcesUrl}/plugins_script.py[py], {rbSourcesUrl}/plugins_script.rb[rb], {groovySourcesUrl}/plugins_script.groovy[groovy], {jsSourcesUrl}/plugins_script.js[js], {pySourcesUrl}/plugins_script.xml[XML configuration])]
|Shows how to define and use a script-based plugin.

|`rules`
ifdef::useReferences[({pySourcesUrl}/rules.py[py], {rbSourcesUrl}/rules.rb[rb], {groovySourcesUrl}/rules.groovy[groovy], {jsSourcesUrl}/rules.js[js])]
|Shows how to define and use ordered rules, i.e. rules listening to ordered sequences of events. Event conditions are specified using lambda expressions as well as class methods.

|`rules_events`
ifdef::useReferences[({pySourcesUrl}/rules_events.py[py], {rbSourcesUrl}/rules_events.rb[rb], {groovySourcesUrl}/rules_events.groovy[groovy], {jsSourcesUrl}/rules_events.js[js], {pySourcesUrl}/rules_events.xml[XML configuration])]
|Shows how to define and use rules that have different event modes, durations etc.

|`rules_heartbeat`
ifdef::useReferences[({pySourcesUrl}/rules_heartbeat.py[py], {rbSourcesUrl}/rules_heartbeat.rb[rb], {groovySourcesUrl}/rules_heartbeat.groovy[groovy], {jsSourcesUrl}/rules_heartbeat.js[js])]
|Heartbeat complete example.

|`rules_none_mode_events_conditions`
ifdef::useReferences[({pySourcesUrl}/rules_none_mode_events_conditions.py[py], {rbSourcesUrl}/rules_none_mode_events_conditions.rb[rb], {groovySourcesUrl}/rules_none_mode_events_conditions.groovy[groovy], {jsSourcesUrl}/rules_none_mode_events_conditions.js[js])]
|Shows how to define and use rules that have `none` event mode and event conditions.

|`rules_none_mode_events`
ifdef::useReferences[({pySourcesUrl}/rules_none_mode_events.py[py], {rbSourcesUrl}/rules_none_mode_events.rb[rb], {groovySourcesUrl}/rules_none_mode_events.groovy[groovy], {jsSourcesUrl}/rules_none_mode_events.js[js])]
|Shows how to define and use rules that have `none` event mode.

|`unordered_rules`
ifdef::useReferences[({pySourcesUrl}/unordered_rules.py[py], {rbSourcesUrl}/unordered_rules.rb[rb], {groovySourcesUrl}/unordered_rules.groovy[groovy], {jsSourcesUrl}/unordered_rules.js[js])]
|Shows how to define and use unordered rules, i.e. rules listening to unordered sequences of events. Event conditions are specified using lambda expressions as well as class methods.

|`triggers`
ifdef::useReferences[({pySourcesUrl}/triggers.py[py], {rbSourcesUrl}/triggers.rb[rb], {groovySourcesUrl}/triggers.groovy[groovy], {jsSourcesUrl}/triggers.js[js], {pySourcesUrl}/triggers.xml[XML configuration])]
|Shows how to define and use triggers.

|`triggers_event_pattern`
ifdef::useReferences[({pySourcesUrl}/triggers_event_pattern.py[py], {rbSourcesUrl}/triggers_event_pattern.rb[rb], {groovySourcesUrl}/triggers_event_pattern.groovy[groovy], {jsSourcesUrl}/triggers_event_pattern.js[js])]
|Shows how to define and use triggers that specify events they listen to as a pattern based on a regular expression.
|===

=== Features examples
The features examples show how to use some of {sponge} features. They are not implemented in all supported scripting languages.

.Features examples
[cols="1,3"]
|===
|Name |Description

|`fibonacci`
ifdef::useReferences[({coreSourcesUrl}/fibonacci.py[py])]
|Shows how to send a chain of events, each carrying a Fibonacci number as an attribute.

|`engine_parameters`
ifdef::useReferences[({coreSourcesUrl}/engine_parameters.xml[xml])]
|Shows how to set engine parameters in the XML configuration file.

|`event_pattern`
ifdef::useReferences[({coreSourcesUrl}/event_pattern.py[py])]
|Shows how to use event name patterns and how to enable/disable processors manually.

|`spring`
ifdef::useReferences[({springSourcesUrl}/spring.py[py], {sourcesUrl}/sponge-spring/src/test/java/org/openksavi/sponge/spring/test/SpringTest.java[java])]
|Shows how to integrate with Spring framework.

|`camel_producer`
ifdef::useReferences[({camelSourcesUrl}/camel_producer.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/SimpleCamelProducerTest.java[java])]
|Shows how to handle messages coming from Apache Camel route by a {sponge} trigger.

|`camel_consumer`
ifdef::useReferences[({camelSourcesUrl}/camel_consumer.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/SimpleCamelConsumerTest.java[java])]
|Shows how to handle messages coming from {sponge} by an Apache Camel route.

|`camel_rss`
ifdef::useReferences[({camelSourcesUrl}/camel_rss.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/CamelRssTest.java[java])]
|Shows how to integrate with Apache Camel to send and handle {sponge} events based on RSS feeds. This example uses a Spring configuration.

|`camel_producer_overridden_action`
ifdef::useReferences[({camelSourcesUrl}/camel_producer_overridden_action.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/CamelProducerOverriddenActionTest.java[java])]
|Shows how to handle messages coming from Apache Camel route by a {sponge} trigger using an overridden Camel producer action.

|`camel_producer_custom_action`
ifdef::useReferences[({camelSourcesUrl}/camel_producer_custom_action.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/CamelProducerCustomActionTest.java[java])]
|Shows how to handle messages coming from Apache Camel route by a {sponge} trigger using a custom Camel producer action.

|`camel_multiple_consumer`
ifdef::useReferences[({camelSourcesUrl}/camel_multiple_consumer.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/CamelMultipleConsumerTest.java[java])]
|Shows sending Camel messages to many endpoints in a single {sponge} trigger.
|===

=== Standalone examples
The standalone examples show how to use some of {sponge} features in the standalone command-line application.

.Standalone examples
[cols="1,3"]
|===
|Name |Description

|`standalone_news`
ifdef::useReferences[({sourcesUrl}/sponge-standalone/examples/standalone/news[sources])]
|This example is based on complete example project of embedding {sponge} - News, but adjusted to a standalone version.

|`standalone_camel_rss_news`
ifdef::useReferences[({sourcesUrl}/sponge-standalone/examples/standalone/camel_rss_news[sources])]
|This example is based on complete example project of embedding {sponge} - Camel RSS News, but adjusted to a standalone version.

|`camel_route_groovy`
ifdef::useReferences[({sourcesUrl}/sponge-examples-projects/sponge-examples-project-standalone-camel-groovy[sources])]
|Camel routes in Groovy Spring configuration.

|`camel_route_xml`
ifdef::useReferences[({sourcesUrl}/sponge-examples-projects/sponge-examples-project-standalone-camel-xml[sources])]
|Camel context and routes in XML Spring configuration.
|===

== Maven artifacts

.{sponge} Maven artifacts
[cols="2,2,1,6"]
|===
|GroupId |ArtifactId |Central Maven Repository |Description

|`org.openksavi.sponge`
|`sponge-parent`
|Yes
|Parent project.

|`org.openksavi.sponge`
|`sponge-bom`
|Yes
|Bill Of Materials style pom.xml.

|`org.openksavi.sponge`
|`sponge-api`
|Yes
|{sponge} API.

|`org.openksavi.sponge`
|`sponge-core`
|Yes
|{sponge} core implementation. You may use this dependency if you don't need a scripting language support, for example when creating knowledge bases only in Java.

|`org.openksavi.sponge`
|`sponge-jython`
|Yes
|Support for Python-based scripting knowledge bases using Jython.

|`org.openksavi.sponge`
|`sponge-jruby`
|Yes
|Support for Ruby-based scripting knowledge bases using JRuby.

|`org.openksavi.sponge`
|`sponge-groovy`
|Yes
|Support for Groovy-based scripting knowledge bases.

|`org.openksavi.sponge`
|`sponge-nashorn`
|Yes
|Support for JavaScript-based scripting knowledge bases using Nashorn.

|`org.openksavi.sponge`
|`sponge-camel`
|Yes
|Apache Camel integration.

|`org.openksavi.sponge`
|`sponge-spring`
|Yes
|Spring framework integration.

|`org.openksavi.sponge`
|`sponge-standalone`
|Yes
|Standalone distribution of {sponge}.

|`org.openksavi.sponge`
|`sponge-signal`
|Yes
|Wrappers for Operating System signals.

|`org.openksavi.sponge`
|`sponge-test`
|Yes
|{sponge} test support.

|`org.openksavi.sponge`
|`sponge-examples-projects`
|No
|Complete example projects.

|`org.openksavi.sponge`
|`sponge-distribution`
|No
|Contains documentation, release configuration, project pages etc.

|`org.openksavi.sponge`
|`sponge-integration-tests`
|No
|{sponge} integration tests.

|`org.openksavi.sponge`
|`sponge-standalone-extensions`
|No
|Dependencies for external libraries used by the standalone command-line application.
|===


include::includes/sponge-user-guide-standalone.adoc[leveloffset=+1]


== Third party software
{sponge} uses third party software released under various open-source licenses.

.Key third party software
[cols="1,1,2"]
|===
|Package |License |Description

|https://commons.apache.org/proper/commons-configuration/[Apache Commons Configuration]
|Apache 2.0
|Used for reading configuration files.

|http://www.jython.org[Jython]
|http://www.jython.org/license.html[Jython license]
|Supports writing scripting knowledge bases in Python.

|http://jruby.org[JRuby]
|EPL 1.0, GPL 2 or LGPL 2.1
|Supports writing scripting knowledge bases in Ruby.

|http://www.groovy-lang.org[Groovy]
|Apache 2.0
|Supports writing scripting knowledge bases in Groovy.

|https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/[Nashorn]
|GPL with a linking exception
|Supports writing scripting knowledge bases in JavaScript.

|http://www.quartz-scheduler.org[Quartz]
|Apache 2.0
|Used for scheduling events (e.g. provides cron functionality).

|http://camel.apache.org[Apache Camel]
|Apache 2.0
|Used as an integration facade to external systems.

|http://projects.spring.io/spring-framework[Spring framework]
|Apache 2.0
|Used for integration with Spring framework.

|https://github.com/google/guava[Guava]
|Apache 2.0
|Used for services and as a utilities library.
|===

The complete list of these libraries may be found in the `THIRD-PARTY.txt` and `licenses.xml` files of the standalone distribution.